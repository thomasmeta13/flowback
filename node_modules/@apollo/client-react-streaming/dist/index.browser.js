import { ApolloLink, InMemoryCache as InMemoryCache$1, Observable as Observable$1, gql, ApolloClient as ApolloClient$1 } from '@apollo/client/index.js';
import { hasDirectives, Observable, removeDirectivesFromDocument, mergeIncrementalData, print } from '@apollo/client/utilities/index.js';
import { invariant } from 'ts-invariant';
import React, { createContext, useEffect, useRef, useMemo, useContext, useSyncExternalStore } from 'react';
import { equal } from '@wry/equality';
import { getSuspenseCache, wrapQueryRef, unwrapQueryRef } from '@apollo/client/react/internal/index.js';
import { useApolloClient, ApolloProvider } from '@apollo/client/react/index.js';
import { stripIgnoredCharacters } from 'graphql';
import { canonicalStringify } from '@apollo/client/cache/index.js';
import { JSONEncodeStream, JSONDecodeStream } from '@apollo/client-react-streaming/stream-utils';

// src/AccumulateMultipartResponsesLink.ts
var AccumulateMultipartResponsesLink = class extends ApolloLink {
  maxDelay;
  constructor(config) {
    super();
    this.maxDelay = config.cutoffDelay;
  }
  request(operation, forward) {
    if (!forward) {
      throw new Error("This is not a terminal link!");
    }
    const operationContainsMultipartDirectives = hasDirectives(
      ["defer"],
      operation.query
    );
    const upstream = forward(operation);
    if (!operationContainsMultipartDirectives)
      return upstream;
    const maxDelay = this.maxDelay;
    let accumulatedData, maxDelayTimeout;
    return new Observable((subscriber) => {
      const upstreamSubscription = upstream.subscribe({
        next: (result) => {
          if (accumulatedData) {
            if (accumulatedData.data && "incremental" in result) {
              accumulatedData.data = mergeIncrementalData(
                accumulatedData.data,
                result
              );
            } else if (result.data) {
              accumulatedData.data = result.data;
            }
            if (result.errors) {
              accumulatedData.errors = [
                ...accumulatedData.errors || [],
                ...result.errors || []
              ];
            }
            if (result.extensions)
              accumulatedData.extensions = {
                ...accumulatedData.extensions,
                ...result.extensions
              };
          } else {
            accumulatedData = result;
          }
          if (!maxDelay) {
            flushAccumulatedData();
          } else if (!maxDelayTimeout) {
            maxDelayTimeout = setTimeout(flushAccumulatedData, maxDelay);
          }
        },
        error: (error) => {
          if (maxDelayTimeout)
            clearTimeout(maxDelayTimeout);
          subscriber.error(error);
        },
        complete: () => {
          if (maxDelayTimeout) {
            clearTimeout(maxDelayTimeout);
            flushAccumulatedData();
          }
          subscriber.complete();
        }
      });
      function flushAccumulatedData() {
        subscriber.next(accumulatedData);
        subscriber.complete();
        upstreamSubscription.unsubscribe();
      }
      return function cleanUp() {
        clearTimeout(maxDelayTimeout);
        upstreamSubscription.unsubscribe();
      };
    });
  }
};
function getDirectiveArgumentValue(directive, argument) {
  return directive.arguments?.find((arg) => arg.name.value === argument)?.value;
}
var RemoveMultipartDirectivesLink = class extends ApolloLink {
  stripDirectives = [];
  constructor(config) {
    super();
    if (config.stripDefer !== false)
      this.stripDirectives.push("defer");
  }
  request(operation, forward) {
    if (!forward) {
      throw new Error("This is not a terminal link!");
    }
    const { query } = operation;
    let modifiedQuery = query;
    modifiedQuery = removeDirectivesFromDocument(
      this.stripDirectives.map((directive) => ({
        test(node) {
          let shouldStrip = node.kind === "Directive" && node.name.value === directive;
          const label = getDirectiveArgumentValue(node, "label");
          if (label?.kind === "StringValue" && label.value.startsWith("SsrDontStrip")) {
            shouldStrip = false;
          }
          return shouldStrip;
        },
        remove: true
      })).concat({
        test(node) {
          if (node.kind !== "Directive")
            return false;
          const label = getDirectiveArgumentValue(node, "label");
          return label?.kind === "StringValue" && label.value.startsWith("SsrStrip");
        },
        remove: true
      }),
      modifiedQuery
    );
    if (modifiedQuery === null) {
      return Observable.of({});
    }
    operation.query = modifiedQuery;
    return forward(operation);
  }
};
var SSRMultipartLink = class extends ApolloLink {
  constructor(config = {}) {
    const combined = ApolloLink.from([
      new RemoveMultipartDirectivesLink({
        stripDefer: config.stripDefer
      }),
      new AccumulateMultipartResponsesLink({
        cutoffDelay: config.cutoffDelay || 0
      })
    ]);
    super(combined.request);
  }
};

// src/bundleInfo.ts
var bundle = {
  pkg: "@apollo/client-react-streaming"
};
var sourceSymbol = Symbol.for("apollo.source_package");

// src/DataTransportAbstraction/WrappedInMemoryCache.tsx
var InMemoryCache = class extends InMemoryCache$1 {
  /**
   * Information about the current package and it's export names, for use in error messages.
   *
   * @internal
   */
  static info = bundle;
  [sourceSymbol];
  constructor(config) {
    super(config);
    const info = this.constructor.info;
    this[sourceSymbol] = `${info.pkg}:InMemoryCache`;
  }
};
var DataTransportContext = /* @__PURE__ */ createContext(null);
var CLEAN = {};
function useTransportValue(value) {
  const dataTransport = useContext(DataTransportContext);
  if (!dataTransport)
    throw new Error(
      "useTransportValue must be used within a streaming-specific ApolloProvider"
    );
  const valueRef = dataTransport.useStaticValueRef(value);
  const whichResult = useSyncExternalStore(
    () => () => {
    },
    () => 0 /* client */,
    () => valueRef.current === CLEAN ? 0 /* client */ : equal(value, valueRef.current) ? 0 /* client */ : 1 /* server */
  );
  if (whichResult === 0 /* client */) {
    valueRef.current = CLEAN;
  }
  return whichResult === 1 /* server */ ? valueRef.current : value;
}
var teeToReadableStreamKey = Symbol.for(
  "apollo.tee.readableStreamController"
);
var readFromReadableStreamKey = Symbol.for("apollo.read.readableStream");
function teeToReadableStream(onLinkHit, context) {
  return Object.assign(context, {
    [teeToReadableStreamKey]: onLinkHit
  });
}
function readFromReadableStream(readableStream, context) {
  return Object.assign(context, {
    [readFromReadableStreamKey]: readableStream
  });
}
var TeeToReadableStreamLink = class extends ApolloLink {
  constructor() {
    super((operation, forward) => {
      const context = operation.getContext();
      const onLinkHit = context[teeToReadableStreamKey];
      if (onLinkHit) {
        const controller = onLinkHit();
        const tryClose = () => {
          try {
            controller.close();
          } catch {
          }
        };
        return new Observable$1((observer) => {
          const subscription = forward(operation).subscribe({
            next(result) {
              controller.enqueue({ type: "next", value: result });
              observer.next(result);
            },
            error(error) {
              controller.enqueue({ type: "error" });
              tryClose();
              observer.error(error);
            },
            complete() {
              controller.enqueue({ type: "completed" });
              tryClose();
              observer.complete();
            }
          });
          return () => {
            tryClose();
            subscription.unsubscribe();
          };
        });
      }
      return forward(operation);
    });
  }
};
var ReadFromReadableStreamLink = class extends ApolloLink {
  constructor() {
    super((operation, forward) => {
      const context = operation.getContext();
      const eventSteam = context[readFromReadableStreamKey];
      if (eventSteam) {
        return new Observable$1((observer) => {
          let aborted = false;
          const reader = (() => {
            try {
              return eventSteam.getReader();
            } catch {
            }
          })();
          if (!reader) {
            const subscription = forward(operation).subscribe(observer);
            return () => subscription.unsubscribe();
          }
          consume(reader);
          let onAbort = () => {
            aborted = true;
            reader.cancel();
          };
          return () => onAbort();
          async function consume(reader2) {
            let event = undefined;
            while (!aborted && !event?.done) {
              event = await reader2.read();
              if (aborted)
                break;
              if (event.value) {
                switch (event.value.type) {
                  case "next":
                    observer.next(event.value.value);
                    break;
                  case "completed":
                    observer.complete();
                    break;
                  case "error":
                    {
                      onAbort();
                      const subscription = forward(operation).subscribe(observer);
                      onAbort = () => subscription.unsubscribe();
                    }
                    break;
                }
              }
            }
          }
        });
      }
      return forward(operation);
    });
  }
};
function serializeOptions(options) {
  return {
    ...options,
    query: printMinified(options.query)
  };
}
function deserializeOptions(options) {
  return {
    ...options,
    // `gql` memoizes results, but based on the input string.
    // We parse-stringify-parse here to ensure that our minified query
    // has the best chance of being the referential same query as the one used in
    // client-side code.
    query: gql(print(gql(options.query)))
  };
}
function printMinified(query) {
  return stripIgnoredCharacters(print(query));
}
function getInjectableEventStream() {
  let controller;
  const stream = new ReadableStream({
    start(c) {
      controller = c;
    }
  });
  return [controller, stream];
}
function createTransportedQueryPreloader(client) {
  return (...[query, options]) => {
    options = { ...options };
    delete options.returnPartialData;
    delete options.nextFetchPolicy;
    delete options.pollInterval;
    const [controller, stream] = getInjectableEventStream();
    client.query({
      query,
      ...options,
      // ensure that this query makes it to the network
      fetchPolicy: "no-cache",
      context: skipDataTransport(
        teeToReadableStream(() => controller, {
          ...options?.context,
          // we want to do this even if the query is already running for another reason
          queryDeduplication: false
        })
      )
    }).catch(() => {
    });
    return createTransportedQueryRef(
      query,
      options,
      crypto.randomUUID(),
      stream
    );
  };
}
function createTransportedQueryRef(query, options, queryKey, stream) {
  return {
    $__apollo_queryRef: {
      options: sanitizeForTransport(serializeOptions({ query, ...options })),
      queryKey,
      stream: stream.pipeThrough(new JSONEncodeStream())
    }
  };
}
var hydrationCache = /* @__PURE__ */ new WeakMap();
function reviveTransportedQueryRef(queryRef, client) {
  const {
    $__apollo_queryRef: { options, stream, queryKey }
  } = queryRef;
  if (!hydrationCache.has(queryRef)) {
    const hydratedOptions = deserializeOptions(options);
    const cacheKey = [
      hydratedOptions.query,
      canonicalStringify(hydratedOptions.variables),
      queryKey
    ];
    hydrationCache.set(queryRef, { cacheKey });
    const internalQueryRef = getSuspenseCache(client).getQueryRef(
      cacheKey,
      () => client.watchQuery({
        ...hydratedOptions,
        fetchPolicy: "network-only",
        context: skipDataTransport(
          readFromReadableStream(stream.pipeThrough(new JSONDecodeStream()), {
            ...hydratedOptions.context,
            queryDeduplication: true
          })
        )
      })
    );
    Object.assign(queryRef, wrapQueryRef(internalQueryRef));
  }
}
function isTransportedQueryRef(queryRef) {
  return !!(queryRef && queryRef.$__apollo_queryRef);
}
function useWrapTransportedQueryRef(queryRef) {
  const client = useApolloClient();
  let cacheKey;
  let isTransported;
  if (isTransported = isTransportedQueryRef(queryRef)) {
    reviveTransportedQueryRef(queryRef, client);
    cacheKey = hydrationCache.get(queryRef)?.cacheKey;
  }
  const unwrapped = unwrapQueryRef(queryRef);
  useEffect(() => {
    if (!isTransported)
      return;
    if (cacheKey) {
      if (unwrapped.disposed) {
        getSuspenseCache(client).add(cacheKey, unwrapped);
      }
    }
  });
  useEffect(() => {
    if (isTransported) {
      return unwrapped.softRetain();
    }
  }, [isTransported, unwrapped]);
  return queryRef;
}
function sanitizeForTransport(value) {
  return JSON.parse(JSON.stringify(value));
}
var hookWrappers = {
  useFragment(orig_useFragment) {
    return wrap(orig_useFragment, ["data", "complete", "missing"]);
  },
  useQuery(orig_useQuery) {
    return wrap(
      orig_useQuery,
      ["data", "loading", "networkStatus", "called"]
    );
  },
  useSuspenseQuery(orig_useSuspenseQuery) {
    return wrap(orig_useSuspenseQuery, ["data", "networkStatus"]);
  },
  useReadQuery(orig_useReadQuery) {
    return wrap(
      (queryRef) => {
        return orig_useReadQuery(useWrapTransportedQueryRef(queryRef));
      },
      ["data", "networkStatus"]
    );
  },
  useQueryRefHandlers(orig_useQueryRefHandlers) {
    return wrap((queryRef) => {
      return orig_useQueryRefHandlers(useWrapTransportedQueryRef(queryRef));
    }, []);
  },
  useSuspenseFragment(orig_useSuspenseFragment) {
    return wrap(orig_useSuspenseFragment, ["data"]);
  }
};
function wrap(useFn, transportKeys) {
  return (...args) => {
    const result = useFn(...args);
    if (transportKeys.length == 0) {
      return result;
    }
    const forTransport = useMemo(() => {
      const transport = {};
      for (const key of transportKeys) {
        transport[key] = result[key];
      }
      return transport;
    }, [result]);
    const transported = useTransportValue(forTransport);
    return useMemo(
      () => ({ ...result, ...transported }),
      [result, transported]
    );
  };
}

// src/assertInstance.ts
function assertInstance(value, info, name) {
  if (value[sourceSymbol] !== `${info.pkg}:${name}`) {
    throw new Error(
      `When using \`${name}\` in streaming SSR, you must use the \`${name}\` export provided by \`"${info.pkg}"\`.`
    );
  }
}

// src/DataTransportAbstraction/WrappedApolloClient.tsx
function getQueryManager(client) {
  return client["queryManager"];
}
var wrappers = Symbol.for("apollo.hook.wrappers");
var ApolloClientBase = class extends ApolloClient$1 {
  /**
   * Information about the current package and it's export names, for use in error messages.
   *
   * @internal
   */
  static info = bundle;
  [sourceSymbol];
  constructor(options) {
    const warnings = [];
    if ("ssrMode" in options) {
      delete options.ssrMode;
      warnings.push(
        "The `ssrMode` option is not supported in %s. Please remove it from your %s constructor options."
      );
    }
    if ("ssrForceFetchDelay" in options) {
      delete options.ssrForceFetchDelay;
      warnings.push(
        "The `ssrForceFetchDelay` option is not supported in %s. Please remove it from your %s constructor options."
      );
    }
    super(
      options
    );
    const info = this.constructor.info;
    this[sourceSymbol] = `${info.pkg}:ApolloClient`;
    for (const warning of warnings) {
      console.warn(warning, info.pkg, "ApolloClient");
    }
    assertInstance(
      this.cache,
      info,
      "InMemoryCache"
    );
    this.setLink(this.link);
  }
  setLink(newLink) {
    super.setLink.call(
      this,
      ApolloLink.from([
        new ReadFromReadableStreamLink(),
        new TeeToReadableStreamLink(),
        newLink
      ])
    );
  }
};
var ApolloClientClientBaseImpl = class extends ApolloClientBase {
  constructor(options) {
    super(options);
    this.onQueryStarted = this.onQueryStarted.bind(this);
    getQueryManager(this)[wrappers] = hookWrappers;
  }
  simulatedStreamingQueries = /* @__PURE__ */ new Map();
  onQueryStarted({ options, id }) {
    const hydratedOptions = deserializeOptions(options);
    const [controller, stream] = getInjectableEventStream();
    const queryManager = getQueryManager(this);
    const queryId = queryManager.generateQueryId();
    queryManager.fetchQuery(queryId, {
      ...hydratedOptions,
      query: queryManager.transform(hydratedOptions.query),
      fetchPolicy: "network-only",
      context: skipDataTransport(
        readFromReadableStream(stream, {
          ...hydratedOptions.context,
          queryDeduplication: true
        })
      )
    }).finally(() => queryManager.removeQuery(queryId));
    this.simulatedStreamingQueries.set(id, {
      controller,
      options: hydratedOptions
    });
  }
  onQueryProgress = (event) => {
    const queryInfo = this.simulatedStreamingQueries.get(event.id);
    if (!queryInfo)
      return;
    if (event.type === "error" || event.type === "next" && event.value.errors) {
      this.simulatedStreamingQueries.delete(event.id);
      {
        invariant.debug(
          "Query failed on server, rerunning in browser:",
          queryInfo.options
        );
        this.rerunSimulatedQuery(queryInfo);
      }
    } else if (event.type === "completed") {
      this.simulatedStreamingQueries.delete(event.id);
      queryInfo.controller.enqueue(event);
    } else if (event.type === "next") {
      queryInfo.controller.enqueue(event);
    }
  };
  /**
   * Can be called when the stream closed unexpectedly while there might still be unresolved
   * simulated server-side queries going on.
   * Those queries will be cancelled and then re-run in the browser.
   */
  rerunSimulatedQueries = () => {
    for (const [id, queryInfo] of this.simulatedStreamingQueries) {
      this.simulatedStreamingQueries.delete(id);
      invariant.debug(
        "streaming connection closed before server query could be fully transported, rerunning:",
        queryInfo.options
      );
      this.rerunSimulatedQuery(queryInfo);
    }
  };
  rerunSimulatedQuery = (queryInfo) => {
    const queryManager = getQueryManager(this);
    const queryId = queryManager.generateQueryId();
    queryManager.fetchQuery(queryId, {
      ...queryInfo.options,
      fetchPolicy: "no-cache",
      query: queryManager.transform(queryInfo.options.query),
      context: skipDataTransport(
        teeToReadableStream(() => queryInfo.controller, {
          ...queryInfo.options.context,
          queryDeduplication: false
        })
      )
    }).finally(() => queryManager.removeQuery(queryId));
  };
};
var skipDataTransportKey = Symbol.for("apollo.dataTransport.skip");
function skipDataTransport(context) {
  return Object.assign(context, {
    [skipDataTransportKey]: true
  });
}
var ApolloClientBrowserImpl = class extends ApolloClientClientBaseImpl {
};
var ApolloClientImplementation = ApolloClientBrowserImpl ;
var ApolloClient = class extends ApolloClientImplementation {
};

// src/DataTransportAbstraction/symbols.ts
var ApolloClientSingleton = /* @__PURE__ */ Symbol.for(
  "ApolloClientSingleton"
);

// src/DataTransportAbstraction/testHelpers.ts
function resetApolloSingletons() {
  delete window[ApolloClientSingleton];
}
function WrapApolloProvider(TransportProvider) {
  const WrappedApolloProvider3 = ({
    makeClient,
    children,
    ...extraProps
  }) => {
    const clientRef = useRef(undefined);
    if (!clientRef.current) {
      {
        clientRef.current = window[ApolloClientSingleton] ??= makeClient();
      }
      assertInstance(
        clientRef.current,
        WrappedApolloProvider3.info,
        "ApolloClient"
      );
    }
    return /* @__PURE__ */ React.createElement(ApolloProvider, { client: clientRef.current }, /* @__PURE__ */ React.createElement(
      TransportProvider,
      {
        onQueryEvent: (event) => event.type === "started" ? clientRef.current.onQueryStarted(event) : clientRef.current.onQueryProgress(event),
        rerunSimulatedQueries: clientRef.current.rerunSimulatedQueries,
        registerDispatchRequestStarted: clientRef.current.watchQueryQueue?.register,
        ...extraProps
      },
      children
    ));
  };
  WrappedApolloProvider3.info = bundle;
  return WrappedApolloProvider3;
}
const built_for_browser = true;

export { ApolloClient, DataTransportContext, AccumulateMultipartResponsesLink as DebounceMultipartResponsesLink, InMemoryCache, ReadFromReadableStreamLink, RemoveMultipartDirectivesLink, SSRMultipartLink, TeeToReadableStreamLink, WrapApolloProvider, built_for_browser, createTransportedQueryPreloader, isTransportedQueryRef, readFromReadableStream, resetApolloSingletons, reviveTransportedQueryRef, skipDataTransport, teeToReadableStream, useWrapTransportedQueryRef };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.browser.js.map