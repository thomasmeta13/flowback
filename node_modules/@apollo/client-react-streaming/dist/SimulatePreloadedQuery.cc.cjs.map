{"version":3,"sources":["../src/SimulatePreloadedQuery.cc.ts","../src/transportedQueryRef.ts","../src/ReadableStreamLink.tsx","../src/DataTransportAbstraction/WrappedInMemoryCache.tsx","../src/bundleInfo.ts","../src/DataTransportAbstraction/WrappedApolloClient.tsx","../src/DataTransportAbstraction/useTransportValue.tsx","../src/DataTransportAbstraction/DataTransportAbstraction.ts","../src/DataTransportAbstraction/hooks.ts","../src/DataTransportAbstraction/transportedOptions.ts","../src/assertInstance.ts","../src/DataTransportAbstraction/WrapApolloProvider.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n  useApolloClient,\n  useBackgroundQuery,\n} from \"@apollo/client/react/index.js\";\nimport { useMemo, type ReactNode } from \"react\";\nimport {\n  reviveTransportedQueryRef,\n  type TransportedQueryRef,\n} from \"./transportedQueryRef.js\";\nimport { deserializeOptions } from \"./DataTransportAbstraction/transportedOptions.js\";\nimport type { PreloadQueryOptions } from \"./PreloadQuery.js\";\n\nexport default function SimulatePreloadedQuery<T>({\n  queryRef,\n  children,\n}: {\n  queryRef: TransportedQueryRef<T>;\n  children: ReactNode;\n}) {\n  const client = useApolloClient();\n  reviveTransportedQueryRef(queryRef, client);\n\n  const bgQueryArgs = useMemo<Parameters<typeof useBackgroundQuery>>(() => {\n    const { query, ...hydratedOptions } = deserializeOptions(\n      queryRef.$__apollo_queryRef.options\n    ) as PreloadQueryOptions<any, T>;\n    return [\n      query,\n      { ...hydratedOptions, queryKey: queryRef.$__apollo_queryRef.queryKey },\n    ] as const;\n  }, [queryRef.$__apollo_queryRef]);\n\n  useBackgroundQuery(...bgQueryArgs);\n\n  return children;\n}\n","import type { CacheKey } from \"@apollo/client/react/internal\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal/index.js\";\nimport {\n  readFromReadableStream,\n  teeToReadableStream,\n} from \"./ReadableStreamLink.js\";\nimport { skipDataTransport } from \"./DataTransportAbstraction/index.js\";\nimport type { ReadableStreamLinkEvent } from \"./ReadableStreamLink.js\";\nimport type { QueryRef } from \"@apollo/client/react/index.js\";\nimport { useApolloClient } from \"@apollo/client/react/index.js\";\nimport type {\n  DocumentNode,\n  ApolloClient,\n  QueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client/index.js\";\nimport {\n  serializeOptions,\n  deserializeOptions,\n  type TransportedOptions,\n} from \"./DataTransportAbstraction/transportedOptions.js\";\nimport { useEffect } from \"react\";\nimport { canonicalStringify } from \"@apollo/client/cache/index.js\";\nimport {\n  JSONDecodeStream,\n  JSONEncodeStream,\n  type JsonString,\n} from \"@apollo/client-react-streaming/stream-utils\";\n\ntype RestrictedPreloadOptions = {\n  fetchPolicy?: \"network-only\" | \"cache-and-network\" | \"cache-first\";\n  returnPartialData?: false;\n  nextFetchPolicy?: undefined;\n  pollInterval?: undefined;\n};\n\n/** @public */\nexport type PreloadTransportedQueryOptions<TVariables, TData> = Omit<\n  QueryOptions<TVariables, TData>,\n  \"query\"\n> &\n  RestrictedPreloadOptions;\n\ntype TransportedQueryRefOptions = TransportedOptions & RestrictedPreloadOptions;\n\n/**\n * A `TransportedQueryRef` is an opaque object accessible via renderProp within `PreloadQuery`.\n *\n * A child client component reading the `TransportedQueryRef` via useReadQuery will suspend until the promise resolves.\n *\n * @public\n */\nexport interface TransportedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> extends QueryRef<TData, TVariables> {\n  /**\n   * Temporarily disabled - see https://github.com/apollographql/apollo-client-integrations/issues/332\n   *\n   * Will now be be `undefined` both in React Server Components and Client Components until we can find a better resolution.\n   */\n  toPromise?: undefined;\n  /** @internal */\n  $__apollo_queryRef: {\n    options: TransportedQueryRefOptions;\n    stream: ReadableStream<JsonString<ReadableStreamLinkEvent>>;\n    /**\n     * A unique key for this query, to ensure it is only hydrated once,\n     * even if it should get transported over the wire in a way that results\n     * in multiple objects describing the same queryRef.\n     * This key will be used to store the queryRef in the suspence cache.\n     *\n     * The chances of this happening should be slim (it is handled within\n     * React thanks to https://github.com/facebook/react/pull/28996), but\n     * as we use transported queryRefs with multiple frameworks with distinct\n     * transport mechanisms, this seems like a safe option.\n     */\n    queryKey: string;\n  };\n}\n\n/** @public */\nexport interface PreloadTransportedQueryFunction {\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options?: PreloadTransportedQueryOptions<NoInfer<TVariables>, TData>\n  ): TransportedQueryRef<TData, TVariables>;\n}\n\n/** @internal */\nexport function getInjectableEventStream() {\n  let controller:\n    | ReadableStreamDefaultController<ReadableStreamLinkEvent>\n    | undefined;\n  const stream = new ReadableStream<ReadableStreamLinkEvent>({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [controller!, stream] as const;\n}\n\n/** @public */\nexport function createTransportedQueryPreloader(\n  client: ApolloClient<any>\n): PreloadTransportedQueryFunction {\n  return (...[query, options]: Parameters<PreloadTransportedQueryFunction>) => {\n    // unset options that we do not support\n    options = { ...options };\n    delete options.returnPartialData;\n    delete options.nextFetchPolicy;\n    delete options.pollInterval;\n\n    const [controller, stream] = getInjectableEventStream();\n\n    // Instead of creating the queryRef, we kick off a query that will feed the network response\n    // into our custom event stream.\n    client\n      .query({\n        query,\n        ...options,\n        // ensure that this query makes it to the network\n        fetchPolicy: \"no-cache\",\n        context: skipDataTransport(\n          teeToReadableStream(() => controller, {\n            ...options?.context,\n            // we want to do this even if the query is already running for another reason\n            queryDeduplication: false,\n          })\n        ),\n      })\n      .catch(() => {\n        /* we want to avoid any floating promise rejections */\n      });\n\n    return createTransportedQueryRef<any, any>(\n      query,\n      options,\n      crypto.randomUUID(),\n      stream\n    );\n  };\n}\n\nfunction createTransportedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: PreloadTransportedQueryOptions<NoInfer<TVariables>, TData>,\n  queryKey: string,\n  stream: ReadableStream<ReadableStreamLinkEvent>\n): TransportedQueryRef<TData, TVariables> {\n  return {\n    $__apollo_queryRef: {\n      options: sanitizeForTransport(serializeOptions({ query, ...options })),\n      queryKey,\n      stream: stream.pipeThrough(new JSONEncodeStream()),\n    },\n  };\n}\n\nconst hydrationCache = new WeakMap<\n  TransportedQueryRef,\n  { cacheKey: CacheKey }\n>();\n\n/** @public */\nexport function reviveTransportedQueryRef(\n  queryRef: TransportedQueryRef,\n  client: ApolloClient<any>\n): asserts queryRef is TransportedQueryRef &\n  ReturnType<typeof wrapQueryRef<any, any>> {\n  const {\n    $__apollo_queryRef: { options, stream, queryKey },\n  } = queryRef;\n  if (!hydrationCache.has(queryRef)) {\n    const hydratedOptions = deserializeOptions(options);\n    const cacheKey: CacheKey = [\n      hydratedOptions.query,\n      canonicalStringify(hydratedOptions.variables),\n      queryKey,\n    ];\n    hydrationCache.set(queryRef, { cacheKey });\n    const internalQueryRef = getSuspenseCache(client).getQueryRef(\n      cacheKey,\n      () =>\n        client.watchQuery({\n          ...hydratedOptions,\n          fetchPolicy: \"network-only\",\n          context: skipDataTransport(\n            readFromReadableStream(stream.pipeThrough(new JSONDecodeStream()), {\n              ...hydratedOptions.context,\n              queryDeduplication: true,\n            })\n          ),\n        })\n    );\n    Object.assign(queryRef, wrapQueryRef(internalQueryRef));\n  }\n}\n\n/** @public */\nexport function isTransportedQueryRef(\n  queryRef: any\n): queryRef is TransportedQueryRef {\n  return !!(queryRef && queryRef.$__apollo_queryRef);\n}\n\n/** @public */\nexport function useWrapTransportedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables> | TransportedQueryRef\n): QueryRef<TData, TVariables> {\n  const client = useApolloClient();\n  let cacheKey: CacheKey | undefined;\n  let isTransported: boolean;\n  if ((isTransported = isTransportedQueryRef(queryRef))) {\n    reviveTransportedQueryRef(queryRef, client);\n    cacheKey = hydrationCache.get(queryRef)?.cacheKey;\n  }\n  const unwrapped = unwrapQueryRef<any>(queryRef)!;\n\n  useEffect(() => {\n    // We only want this to execute if the queryRef is a transported query.\n    if (!isTransported) return;\n    // We want to always keep this queryRef in the suspense cache in case another component has another instance of this transported queryRef.\n    if (cacheKey) {\n      if (unwrapped.disposed) {\n        getSuspenseCache(client).add(cacheKey, unwrapped);\n      }\n    }\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n  // Soft-retaining because useQueryRefHandlers doesn't do it for us.\n  useEffect(() => {\n    if (isTransported) {\n      return unwrapped.softRetain();\n    }\n  }, [isTransported, unwrapped]);\n  return queryRef;\n}\n\nfunction sanitizeForTransport<T>(value: T) {\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n","import { ApolloLink, Observable } from \"@apollo/client/index.js\";\nimport type { FetchResult } from \"@apollo/client/index.js\";\n\n/**\n * @internal\n */\nexport type ReadableStreamLinkEvent =\n  | { type: \"next\"; value: FetchResult }\n  | { type: \"completed\" }\n  | { type: \"error\" };\n\n/**\n * Called when the link is hit, before the request is forwarded.\n *\n * Should return the controller for the readable stream.\n *\n * This is useful because when starting a query, it's not always\n * clear if the query will hit the network or will be served from\n * cache, deduplicated etc.\n * This allows to inject the \"start event\" into the stream only\n * when we know that more chunks will actually follow.\n */\ntype OnLinkHitFunction =\n  () => ReadableStreamDefaultController<ReadableStreamLinkEvent>;\ninterface InternalContext {\n  [teeToReadableStreamKey]?: OnLinkHitFunction;\n  [readFromReadableStreamKey]?: ReadableStream<ReadableStreamLinkEvent>;\n}\n\nconst teeToReadableStreamKey = Symbol.for(\n  \"apollo.tee.readableStreamController\"\n);\nconst readFromReadableStreamKey = Symbol.for(\"apollo.read.readableStream\");\n\n/**\n * Apply to a context that will be passed to a link chain containing `TeeToReadableStreamLink`.\n * @public\n */\nexport function teeToReadableStream<T extends Record<string, any>>(\n  onLinkHit: OnLinkHitFunction,\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [teeToReadableStreamKey]: onLinkHit,\n  });\n}\n\n/**\n * Apply to a context that will be passed to a link chain containing `ReadFromReadableStreamLink`.\n * @public\n */\nexport function readFromReadableStream<T extends Record<string, any>>(\n  readableStream: ReadableStream<ReadableStreamLinkEvent>,\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [readFromReadableStreamKey]: readableStream,\n  });\n}\n\n/**\n * A link that allows the request to be cloned into a readable stream, e.g. for\n * transport of multipart responses from RSC or a server loader to the browser.\n * @public\n */\nexport class TeeToReadableStreamLink extends ApolloLink {\n  constructor() {\n    super((operation, forward) => {\n      const context = operation.getContext() as InternalContext;\n\n      const onLinkHit = context[teeToReadableStreamKey];\n\n      if (onLinkHit) {\n        const controller = onLinkHit();\n\n        const tryClose = () => {\n          try {\n            controller.close();\n          } catch {\n            // maybe we already tried to close the stream, nothing to worry about\n          }\n        };\n        return new Observable((observer) => {\n          const subscription = forward(operation).subscribe({\n            next(result) {\n              controller.enqueue({ type: \"next\", value: result });\n              observer.next(result);\n            },\n            error(error) {\n              controller.enqueue({ type: \"error\" });\n              tryClose();\n              observer.error(error);\n            },\n            complete() {\n              controller.enqueue({ type: \"completed\" });\n              tryClose();\n              observer.complete();\n            },\n          });\n\n          return () => {\n            tryClose();\n            subscription.unsubscribe();\n          };\n        });\n      }\n\n      return forward(operation);\n    });\n  }\n}\n\n/**\n * A link that allows the response to be read from a readable stream, e.g. for\n * hydration of a multipart response from RSC or a server loader in the browser.\n * @public\n */\nexport class ReadFromReadableStreamLink extends ApolloLink {\n  constructor() {\n    super((operation, forward) => {\n      const context = operation.getContext() as InternalContext;\n\n      const eventSteam = context[readFromReadableStreamKey];\n      if (eventSteam) {\n        return new Observable((observer) => {\n          let aborted = false as boolean;\n          const reader = (() => {\n            try {\n              return eventSteam.getReader();\n            } catch {\n              /**\n               * The reader could not be created, usually because the stream has\n               * already been consumed.\n               * This would be the case if we call `refetch` on a queryRef that has\n               * the `readFromReadableStreamKey` property in context.\n               * In that case, we want to do a normal network request.\n               */\n            }\n          })();\n\n          if (!reader) {\n            // if we can't create a reader, we want to do a normal network request\n            const subscription = forward(operation).subscribe(observer);\n            return () => subscription.unsubscribe();\n          }\n          consume(reader);\n\n          let onAbort = () => {\n            aborted = true;\n            reader.cancel();\n          };\n\n          return () => onAbort();\n\n          async function consume(\n            reader: ReadableStreamDefaultReader<ReadableStreamLinkEvent>\n          ) {\n            let event:\n              | ReadableStreamReadResult<ReadableStreamLinkEvent>\n              | undefined = undefined;\n            while (!aborted && !event?.done) {\n              event = await reader.read();\n              if (aborted) break;\n              if (event.value) {\n                switch (event.value.type) {\n                  case \"next\":\n                    observer.next(event.value.value);\n                    break;\n                  case \"completed\":\n                    observer.complete();\n                    break;\n                  case \"error\":\n                    // in case a network error happened on the sending side,\n                    if (process.env.REACT_ENV === \"ssr\") {\n                      // we want to fail SSR for this tree\n                      observer.error(\n                        new Error(\n                          \"Error from event stream. Redacted for security concerns.\"\n                        )\n                      );\n                    } else {\n                      // we want to retry the operation on the receiving side\n                      onAbort();\n                      const subscription =\n                        forward(operation).subscribe(observer);\n                      onAbort = () => subscription.unsubscribe();\n                    }\n                    break;\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return forward(operation);\n    });\n  }\n}\n","import type { InMemoryCacheConfig } from \"@apollo/client/index.js\";\nimport { InMemoryCache as OrigInMemoryCache } from \"@apollo/client/index.js\";\nimport { bundle, sourceSymbol } from \"../bundleInfo.js\";\n/*\n * We just subclass `InMemoryCache` here so that `WrappedApolloClient`\n * can detect if it was initialized with an `InMemoryCache` instance that\n * was also exported from this package.\n * Right now, we don't have extra logic here, but we might have so again\n * in the future.\n * So we want to enforce this import path from the start to prevent future\n * subtle bugs if people update the package and don't read the patch notes.\n */\n/**\n * A version of `InMemoryCache` to be used with streaming SSR.\n *\n * For more documentation, please see {@link https://www.apollographql.com/docs/react/api/cache/InMemoryCache | the Apollo Client API documentation}.\n *\n * @public\n */\nexport class InMemoryCache extends OrigInMemoryCache {\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   *\n   * @internal\n   */\n  static readonly info = bundle;\n  [sourceSymbol]: string;\n  constructor(config?: InMemoryCacheConfig | undefined) {\n    super(config);\n    const info = (this.constructor as typeof InMemoryCache).info;\n    this[sourceSymbol] = `${info.pkg}:InMemoryCache`;\n  }\n}\n","export const bundle = {\n  pkg: \"@apollo/client-react-streaming\",\n};\n\nexport const sourceSymbol = Symbol.for(\"apollo.source_package\");\n","/* eslint-disable prefer-rest-params */\nimport type {\n  ApolloClientOptions,\n  OperationVariables,\n  WatchQueryOptions,\n  NormalizedCacheObject,\n} from \"@apollo/client/index.js\";\n\nimport {\n  ApolloLink,\n  ApolloClient as OrigApolloClient,\n  Observable,\n} from \"@apollo/client/index.js\";\nimport type { QueryManager } from \"@apollo/client/core/QueryManager.js\";\nimport { invariant } from \"ts-invariant\";\nimport { createBackpressuredCallback } from \"./backpressuredCallback.js\";\nimport type { InMemoryCache } from \"./WrappedInMemoryCache.js\";\nimport { hookWrappers } from \"./hooks.js\";\nimport type { HookWrappers } from \"@apollo/client/react/internal/index.js\";\nimport type {\n  ProgressEvent,\n  QueryEvent,\n  TransportIdentifier,\n} from \"./DataTransportAbstraction.js\";\nimport { bundle, sourceSymbol } from \"../bundleInfo.js\";\nimport { serializeOptions, deserializeOptions } from \"./transportedOptions.js\";\nimport { assertInstance } from \"../assertInstance.js\";\nimport type { ReadableStreamLinkEvent } from \"../ReadableStreamLink.js\";\nimport {\n  readFromReadableStream,\n  ReadFromReadableStreamLink,\n  teeToReadableStream,\n  TeeToReadableStreamLink,\n} from \"../ReadableStreamLink.js\";\nimport { getInjectableEventStream } from \"../transportedQueryRef.js\";\n\nfunction getQueryManager(\n  client: OrigApolloClient<unknown>\n): QueryManager<NormalizedCacheObject> & {\n  [wrappers]: HookWrappers;\n} {\n  return client[\"queryManager\"];\n}\n\ntype SimulatedQueryInfo = {\n  controller: ReadableStreamDefaultController<ReadableStreamLinkEvent>;\n  options: WatchQueryOptions<OperationVariables, any>;\n};\n\ninterface WrappedApolloClientOptions\n  extends Omit<\n    ApolloClientOptions<NormalizedCacheObject>,\n    \"cache\" | \"ssrMode\" | \"ssrForceFetchDelay\"\n  > {\n  cache: InMemoryCache;\n}\n\nconst wrappers = Symbol.for(\"apollo.hook.wrappers\");\nclass ApolloClientBase extends OrigApolloClient<NormalizedCacheObject> {\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   *\n   * @internal\n   */\n  static readonly info = bundle;\n\n  [sourceSymbol]: string;\n\n  constructor(options: WrappedApolloClientOptions) {\n    const warnings: string[] = [];\n    if (\"ssrMode\" in options) {\n      delete options.ssrMode;\n      warnings.push(\n        \"The `ssrMode` option is not supported in %s. Please remove it from your %s constructor options.\"\n      );\n    }\n    if (\"ssrForceFetchDelay\" in options) {\n      delete options.ssrForceFetchDelay;\n      warnings.push(\n        \"The `ssrForceFetchDelay` option is not supported in %s. Please remove it from your %s constructor options.\"\n      );\n    }\n    super(\n      process.env.REACT_ENV === \"rsc\" || process.env.REACT_ENV === \"ssr\"\n        ? {\n            connectToDevTools: false,\n            ...options,\n          }\n        : options\n    );\n    const info = (this.constructor as typeof ApolloClientBase).info;\n    this[sourceSymbol] = `${info.pkg}:ApolloClient`;\n\n    for (const warning of warnings) {\n      console.warn(warning, info.pkg, \"ApolloClient\");\n    }\n\n    assertInstance(\n      this.cache as unknown as InMemoryCache,\n      info,\n      \"InMemoryCache\"\n    );\n\n    this.setLink(this.link);\n  }\n\n  setLink(newLink: ApolloLink) {\n    super.setLink.call(\n      this,\n      ApolloLink.from([\n        new ReadFromReadableStreamLink(),\n        new TeeToReadableStreamLink(),\n        newLink,\n      ])\n    );\n  }\n}\n\nclass ApolloClientClientBaseImpl extends ApolloClientBase {\n  constructor(options: WrappedApolloClientOptions) {\n    super(options);\n    this.onQueryStarted = this.onQueryStarted.bind(this);\n\n    getQueryManager(this)[wrappers] = hookWrappers;\n  }\n\n  private simulatedStreamingQueries = new Map<\n    TransportIdentifier,\n    SimulatedQueryInfo\n  >();\n\n  onQueryStarted({ options, id }: Extract<QueryEvent, { type: \"started\" }>) {\n    const hydratedOptions = deserializeOptions(options);\n\n    const [controller, stream] = getInjectableEventStream();\n\n    const queryManager = getQueryManager(this);\n    const queryId = queryManager.generateQueryId();\n    queryManager\n      .fetchQuery(queryId, {\n        ...hydratedOptions,\n        query: queryManager.transform(hydratedOptions.query),\n        fetchPolicy: \"network-only\",\n        context: skipDataTransport(\n          readFromReadableStream(stream, {\n            ...hydratedOptions.context,\n            queryDeduplication: true,\n          })\n        ),\n      })\n      .finally(() => queryManager.removeQuery(queryId));\n\n    this.simulatedStreamingQueries.set(id, {\n      controller,\n      options: hydratedOptions,\n    });\n  }\n\n  onQueryProgress = (event: ProgressEvent) => {\n    const queryInfo = this.simulatedStreamingQueries.get(event.id);\n    if (!queryInfo) return;\n\n    if (\n      event.type === \"error\" ||\n      (event.type === \"next\" && event.value.errors)\n    ) {\n      /**\n       * At this point we're not able to correctly serialize the error over the wire\n       * so we do the next-best thing: restart the query in the browser as soon as it\n       * failed on the server.\n       * This matches up with what React will be doing (abort hydration and rerender)\n       * See https://github.com/apollographql/apollo-client-integrations/issues/52\n       */\n      this.simulatedStreamingQueries.delete(event.id);\n      if (process.env.REACT_ENV === \"browser\") {\n        invariant.debug(\n          \"Query failed on server, rerunning in browser:\",\n          queryInfo.options\n        );\n        this.rerunSimulatedQuery(queryInfo);\n      } else if (process.env.REACT_ENV === \"ssr\") {\n        invariant.debug(\n          \"Query failed upstream, will fail it during SSR and rerun it in the browser:\",\n          queryInfo.options\n        );\n        queryInfo.controller.error(new Error(\"Query failed upstream.\"));\n      }\n    } else if (event.type === \"completed\") {\n      this.simulatedStreamingQueries.delete(event.id);\n      queryInfo.controller.enqueue(event);\n    } else if (event.type === \"next\") {\n      queryInfo.controller.enqueue(event);\n    }\n  };\n\n  /**\n   * Can be called when the stream closed unexpectedly while there might still be unresolved\n   * simulated server-side queries going on.\n   * Those queries will be cancelled and then re-run in the browser.\n   */\n  rerunSimulatedQueries = () => {\n    for (const [id, queryInfo] of this.simulatedStreamingQueries) {\n      this.simulatedStreamingQueries.delete(id);\n      invariant.debug(\n        \"streaming connection closed before server query could be fully transported, rerunning:\",\n        queryInfo.options\n      );\n      this.rerunSimulatedQuery(queryInfo);\n    }\n  };\n  rerunSimulatedQuery = (queryInfo: SimulatedQueryInfo) => {\n    const queryManager = getQueryManager(this);\n    const queryId = queryManager.generateQueryId();\n    queryManager\n      .fetchQuery(queryId, {\n        ...queryInfo.options,\n        fetchPolicy: \"no-cache\",\n        query: queryManager.transform(queryInfo.options.query),\n        context: skipDataTransport(\n          teeToReadableStream(() => queryInfo.controller, {\n            ...queryInfo.options.context,\n            queryDeduplication: false,\n          })\n        ),\n      })\n      .finally(() => queryManager.removeQuery(queryId));\n  };\n}\n\nconst skipDataTransportKey = Symbol.for(\"apollo.dataTransport.skip\");\ninterface InternalContext {\n  [skipDataTransportKey]?: boolean;\n}\n\n/**\n * Apply to a context to prevent this operation from being transported over the SSR data transport mechanism.\n * @public\n */\nexport function skipDataTransport<T extends Record<string, any>>(\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [skipDataTransportKey]: true,\n  });\n}\n\nclass ApolloClientSSRImpl extends ApolloClientClientBaseImpl {\n  watchQueryQueue = createBackpressuredCallback<{\n    event: Extract<QueryEvent, { type: \"started\" }>;\n    observable: Observable<Exclude<QueryEvent, { type: \"started\" }>>;\n  }>();\n\n  pushEventStream(\n    options: WatchQueryOptions<any, any>\n  ): ReadableStreamDefaultController<ReadableStreamLinkEvent> {\n    const id = crypto.randomUUID() as TransportIdentifier;\n\n    const [controller, eventStream] = getInjectableEventStream();\n\n    const streamObservable = new Observable<\n      Exclude<QueryEvent, { type: \"started\" }>\n    >((subscriber) => {\n      function consume(\n        event: ReadableStreamReadResult<ReadableStreamLinkEvent>\n      ) {\n        const value = event.value;\n        if (value) {\n          subscriber.next({ ...value, id });\n        }\n        if (event.done) {\n          subscriber.complete();\n        } else {\n          reader.read().then(consume);\n        }\n      }\n      const reader = eventStream.getReader();\n      reader.read().then(consume);\n    });\n\n    this.watchQueryQueue.push({\n      event: {\n        type: \"started\",\n        options: serializeOptions(options),\n        id,\n      },\n      observable: streamObservable,\n    });\n\n    return controller;\n  }\n\n  watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>) {\n    if (\n      !(options.context as InternalContext | undefined)?.[skipDataTransportKey]\n    ) {\n      return super.watchQuery({\n        ...options,\n        context: teeToReadableStream(() => this.pushEventStream(options), {\n          ...options?.context,\n        }),\n      });\n    }\n    return super.watchQuery(options);\n  }\n}\n\nclass ApolloClientBrowserImpl extends ApolloClientClientBaseImpl {}\n\nclass ApolloClientRSCImpl extends ApolloClientBase {}\n\nconst ApolloClientImplementation =\n  /*#__PURE__*/ process.env.REACT_ENV === \"ssr\"\n    ? ApolloClientSSRImpl\n    : process.env.REACT_ENV === \"browser\"\n      ? ApolloClientBrowserImpl\n      : ApolloClientRSCImpl;\n\n/**\n * A version of `ApolloClient` to be used with streaming SSR or in React Server Components.\n *\n * For more documentation, please see {@link https://www.apollographql.com/docs/react/api/core/ApolloClient | the Apollo Client API documentation}.\n *\n * @public\n */\nexport class ApolloClient<\n    // this generic is obsolete as we require a `InMemoryStore`, which fixes this generic to `NormalizedCacheObject` anyways\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Ignored = NormalizedCacheObject,\n  >\n  extends (ApolloClientImplementation as typeof ApolloClientBase)\n  implements Partial<ApolloClientSSRImpl>\n{\n  /** @internal */\n  declare onQueryStarted?: ApolloClientSSRImpl[\"onQueryStarted\"];\n  /** @internal */\n  declare onQueryProgress?: ApolloClientSSRImpl[\"onQueryProgress\"];\n  /** @internal */\n  declare rerunSimulatedQueries?: ApolloClientSSRImpl[\"rerunSimulatedQueries\"];\n  /** @internal */\n  declare rerunSimulatedQuery?: ApolloClientSSRImpl[\"rerunSimulatedQuery\"];\n  /** @internal */\n  declare watchQueryQueue?: ApolloClientSSRImpl[\"watchQueryQueue\"];\n}\n","\"use client\";\nimport { useContext, useSyncExternalStore } from \"react\";\nimport { DataTransportContext } from \"./DataTransportAbstraction.js\";\nimport { equal } from \"@wry/equality\";\n\nconst CLEAN = {};\nconst enum WhichResult {\n  client,\n  server,\n}\n\n/**\n * A hook that mostly acts as an identity function.\n * It will only behave differently during\n * the first render on the client, in which case it will\n * try to return the last value it was called with by\n * the same component during SSR. If that is successful,\n * it will schedule another rerender, to after hydration\n * the component can change to client-side values instead.\n */\nexport function useTransportValue<T>(value: T): T {\n  const dataTransport = useContext(DataTransportContext);\n  if (!dataTransport)\n    throw new Error(\n      \"useTransportValue must be used within a streaming-specific ApolloProvider\"\n    );\n  const valueRef = dataTransport.useStaticValueRef<T | typeof CLEAN>(value);\n\n  const whichResult = useSyncExternalStore(\n    () => () => {},\n    () => WhichResult.client,\n    () =>\n      valueRef.current === CLEAN\n        ? WhichResult.client\n        : equal(value, valueRef.current)\n          ? WhichResult.client\n          : WhichResult.server\n  );\n\n  if (whichResult === WhichResult.client) {\n    // this value will never be used again\n    // so we can safely delete it to save memory\n    valueRef.current = CLEAN;\n  }\n\n  return whichResult === WhichResult.server ? (valueRef.current as T) : value;\n}\n","import type React from \"react\";\nimport type { Observable } from \"@apollo/client/index.js\";\nimport { createContext } from \"react\";\nimport type { TransportedOptions } from \"./transportedOptions.js\";\nimport type { ReadableStreamLinkEvent } from \"../ReadableStreamLink.ts\";\n\ninterface DataTransportAbstraction {\n  /**\n   * This hook should always return the first value it was called with.\n   *\n   * If used in the browser and SSR happened, it should return the value passed to it on the server.\n   */\n  useStaticValueRef<T>(value: T): { current: T };\n}\n\n/**\n * > This export is only available in React Client Components\n *\n * If you create a custom data transport, you need to wrap the child tree in a\n * `DataTransportContext.Provider` and provide the `DataTransportAbstraction` to it.\n *\n * See for example\n * https://github.com/apollographql/apollo-client-integrations/blob/37feeaa9aea69b90a974eb9cd0fbd636b62d841a/integration-test/experimental-react/src/WrappedApolloProvider.tsx\n *\n * @public\n */\nexport const DataTransportContext =\n  /*#__PURE__*/ createContext<DataTransportAbstraction | null>(null);\n\n/**\n * Interface to be implemented by a custom data transport component,\n * for usage with `WrapApolloProvider`.\n *\n * This component needs to provide a `DataTransportContext` to it's children.\n *\n * See for example\n * https://github.com/apollographql/apollo-client-integrations/blob/37feeaa9aea69b90a974eb9cd0fbd636b62d841a/integration-test/experimental-react/src/WrappedApolloProvider.tsx\n *\n * @public\n */\nexport type DataTransportProviderImplementation<\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ExtraProps = {},\n> = React.FC<\n  {\n    /** will be present in the Browser */\n    onQueryEvent?: (event: QueryEvent) => void;\n    /** will be present in the Browser */\n    rerunSimulatedQueries?: () => void;\n    /** will be present during SSR */\n    registerDispatchRequestStarted?: (\n      callback: (query: {\n        event: Extract<QueryEvent, { type: \"started\" }>;\n        observable: Observable<Exclude<QueryEvent, { type: \"started\" }>>;\n      }) => void\n    ) => void;\n    /** will always be present */\n    children: React.ReactNode;\n  } & ExtraProps\n>;\n\nexport type TransportIdentifier = string & { __transportIdentifier: true };\n\n/**\n * Events that will be emitted by a wrapped ApolloClient instance during\n * SSR on `DataTransportProviderImplementation.registerDispatchRequestStarted`,\n * to be transported to the browser and replayed there using\n * `DataTransportProviderImplementation.onQueryEvent`.\n *\n * @public\n */\nexport type QueryEvent =\n  | {\n      type: \"started\";\n      options: TransportedOptions;\n      id: TransportIdentifier;\n    }\n  | (ReadableStreamLinkEvent & {\n      id: TransportIdentifier;\n    });\n\nexport type ProgressEvent = Exclude<QueryEvent, { type: \"started\" }>;\n","import type { HookWrappers } from \"@apollo/client/react/internal/index.js\";\nimport { useTransportValue } from \"./useTransportValue.js\";\nimport { useWrapTransportedQueryRef } from \"../transportedQueryRef.js\";\nimport { useMemo } from \"react\";\n\nexport const hookWrappers: HookWrappers = {\n  useFragment(orig_useFragment) {\n    return wrap(orig_useFragment, [\"data\", \"complete\", \"missing\"]);\n  },\n  useQuery(orig_useQuery) {\n    return wrap<typeof orig_useQuery>(\n      process.env.REACT_ENV === \"ssr\"\n        ? (query, options) =>\n            orig_useQuery(query, { ...options, fetchPolicy: \"cache-only\" })\n        : orig_useQuery,\n      [\"data\", \"loading\", \"networkStatus\", \"called\"]\n    );\n  },\n  useSuspenseQuery(orig_useSuspenseQuery) {\n    return wrap(orig_useSuspenseQuery, [\"data\", \"networkStatus\"]);\n  },\n  useReadQuery(orig_useReadQuery) {\n    return wrap(\n      (queryRef) => {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        return orig_useReadQuery(useWrapTransportedQueryRef(queryRef));\n      },\n      [\"data\", \"networkStatus\"]\n    );\n  },\n  useQueryRefHandlers(orig_useQueryRefHandlers) {\n    return wrap((queryRef) => {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      return orig_useQueryRefHandlers(useWrapTransportedQueryRef(queryRef));\n    }, []);\n  },\n  useSuspenseFragment(orig_useSuspenseFragment) {\n    return wrap(orig_useSuspenseFragment, [\"data\"]);\n  },\n};\n\nfunction wrap<T extends (...args: any[]) => any>(\n  useFn: T,\n  transportKeys: (keyof ReturnType<T>)[]\n): T {\n  return ((...args: any[]) => {\n    const result = useFn(...args);\n    if (transportKeys.length == 0) {\n      return result;\n    }\n    const forTransport = useMemo<Partial<typeof result>>(() => {\n      const transport: Partial<typeof result> = {};\n      for (const key of transportKeys) {\n        transport[key] = result[key];\n      }\n      return transport;\n    }, [result]);\n    const transported = useTransportValue(forTransport);\n\n    return useMemo(\n      () => ({ ...result, ...transported }),\n      [result, transported]\n    );\n  }) as T;\n}\n","import { gql } from \"@apollo/client/index.js\";\nimport type {\n  WatchQueryOptions,\n  DocumentNode,\n  FetchPolicy,\n} from \"@apollo/client/index.js\";\nimport { print } from \"@apollo/client/utilities/index.js\";\nimport { stripIgnoredCharacters } from \"graphql\";\n\nexport type TransportedOptions = { query: string } & Omit<\n  WatchQueryOptions,\n  \"query\"\n>;\n\nexport function serializeOptions<T extends WatchQueryOptions<any, any>>(\n  options: T\n): { query: string; nextFetchPolicy?: FetchPolicy | undefined } & Omit<\n  T,\n  \"query\"\n> {\n  return {\n    ...(options as typeof options & {\n      // little bit of a hack around the method signature, but the method signature would cause React to error anyways\n      nextFetchPolicy?: FetchPolicy | undefined;\n    }),\n    query: printMinified(options.query),\n  };\n}\n\nexport function deserializeOptions(\n  options: TransportedOptions\n): WatchQueryOptions {\n  return {\n    ...options,\n    // `gql` memoizes results, but based on the input string.\n    // We parse-stringify-parse here to ensure that our minified query\n    // has the best chance of being the referential same query as the one used in\n    // client-side code.\n    query: gql(print(gql(options.query))),\n  };\n}\n\nfunction printMinified(query: DocumentNode): string {\n  return stripIgnoredCharacters(print(query));\n}\n","import type { bundle } from \"./bundleInfo.js\";\nimport { sourceSymbol } from \"./bundleInfo.js\";\n\nexport function assertInstance(\n  value: { [sourceSymbol]?: string },\n  info: typeof bundle,\n  name: string\n): void {\n  if (value[sourceSymbol] !== `${info.pkg}:${name}`) {\n    throw new Error(\n      `When using \\`${name}\\` in streaming SSR, you must use the \\`${name}\\` export provided by \\`\"${info.pkg}\"\\`.`\n    );\n  }\n}\n","\"use client\";\nimport React from \"react\";\nimport { useRef } from \"react\";\nimport type { ApolloClient } from \"./WrappedApolloClient.js\";\nimport { ApolloProvider } from \"@apollo/client/react/index.js\";\nimport type { DataTransportProviderImplementation } from \"./DataTransportAbstraction.js\";\nimport { ApolloClientSingleton } from \"./symbols.js\";\nimport { bundle } from \"../bundleInfo.js\";\nimport { assertInstance } from \"../assertInstance.js\";\n\ndeclare global {\n  interface Window {\n    [ApolloClientSingleton]?: ApolloClient<any>;\n  }\n}\n\n/**\n * > This is only available in React Client Components\n *\n * A version of `ApolloProvider` particularly suited for React's streaming SSR.\n *\n * @public\n */\nexport interface WrappedApolloProvider<ExtraProps> {\n  ({\n    makeClient,\n    children,\n    ...extraProps\n  }: React.PropsWithChildren<\n    {\n      makeClient: () => ApolloClient<any>;\n    } & ExtraProps\n  >): React.JSX.Element;\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   */\n  info: {\n    pkg: string;\n  };\n}\n\n/**\n * > This export is only available in React Client Components\n *\n * Creates an ApolloProvider for streaming SSR.\n *\n * @param TransportProvider - The transport provider to be used.\n * This could e.g. be a `ManualDataTransport` created by `buildManualDataTransport`,\n * or a fully custom implementation of `DataTransportProviderImplementation`.\n * @public\n */\nexport function WrapApolloProvider<ExtraProps>(\n  TransportProvider: DataTransportProviderImplementation<ExtraProps>\n): WrappedApolloProvider<ExtraProps> {\n  const WrappedApolloProvider: WrappedApolloProvider<ExtraProps> = ({\n    makeClient,\n    children,\n    ...extraProps\n  }) => {\n    const clientRef = useRef<ApolloClient<any>>(undefined);\n    if (!clientRef.current) {\n      if (process.env.REACT_ENV === \"ssr\") {\n        clientRef.current = makeClient();\n      } else {\n        clientRef.current = window[ApolloClientSingleton] ??= makeClient();\n      }\n      assertInstance(\n        clientRef.current,\n        WrappedApolloProvider.info,\n        \"ApolloClient\"\n      );\n    }\n\n    return (\n      <ApolloProvider client={clientRef.current}>\n        <TransportProvider\n          onQueryEvent={(event) =>\n            event.type === \"started\"\n              ? clientRef.current!.onQueryStarted!(event)\n              : clientRef.current!.onQueryProgress!(event)\n          }\n          rerunSimulatedQueries={clientRef.current.rerunSimulatedQueries}\n          registerDispatchRequestStarted={\n            clientRef.current.watchQueryQueue?.register\n          }\n          {...(extraProps as ExtraProps)}\n        >\n          {children}\n        </TransportProvider>\n      </ApolloProvider>\n    );\n  };\n  WrappedApolloProvider.info = bundle;\n  return WrappedApolloProvider;\n}\n"],"mappings":"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","names":["import_react","reader","import_client","OrigInMemoryCache","import_client","import_react","import_react","import_client","OrigApolloClient","import_react","import_react","import_react"]}