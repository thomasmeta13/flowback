{"version":3,"sources":["../src/registerApolloClient.tsx","../src/PreloadQuery.tsx","../src/transportedQueryRef.ts","../src/ReadableStreamLink.tsx","../src/DataTransportAbstraction/WrappedInMemoryCache.tsx","../src/bundleInfo.ts","../src/DataTransportAbstraction/WrappedApolloClient.tsx","../src/DataTransportAbstraction/useTransportValue.tsx","../src/DataTransportAbstraction/DataTransportAbstraction.ts","../src/DataTransportAbstraction/hooks.ts","../src/DataTransportAbstraction/transportedOptions.ts","../src/assertInstance.ts","../src/DataTransportAbstraction/WrapApolloProvider.tsx","../src/AccumulateMultipartResponsesLink.ts","../src/RemoveMultipartDirectivesLink.ts","../src/SSRMultipartLink.ts"],"names":["React","reader","ApolloLink","Observable","PreloadQuery"],"mappings":"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","sourcesContent":["import type { ApolloClient, OperationVariables } from \"@apollo/client/index.js\";\nimport React from \"react\";\nimport { cache } from \"react\";\nimport type { ReactNode } from \"react\";\nimport type { PreloadQueryOptions } from \"./PreloadQuery.js\";\nimport { PreloadQuery as UnboundPreloadQuery } from \"./PreloadQuery.js\";\nimport type { TransportedQueryRef } from \"./transportedQueryRef.js\";\n\nconst seenWrappers = WeakSet\n  ? new WeakSet<{ client: ApolloClient<any> | Promise<ApolloClient<any>> }>()\n  : undefined;\nconst seenClients = WeakSet\n  ? new WeakSet<ApolloClient<any> | Promise<ApolloClient<any>>>()\n  : undefined;\n\nconst checkForStableCache = cache(() => ({}));\n\n/**\n * > This export is only available in React Server Components\n *\n * Ensures that you can always access the same instance of ApolloClient\n * during RSC for an ongoing request, while always returning\n * a new instance for different requests.\n *\n * @example\n * ```ts\n * export const { getClient, query, PreloadQuery } = registerApolloClient(() => {\n *   return new ApolloClient({\n *     cache: new InMemoryCache(),\n *     link: new HttpLink({\n *       uri: \"http://example.com/api/graphql\",\n *     }),\n *   });\n * });\n * ```\n *\n * @public\n */\nexport function registerApolloClient<\n  ApolloClientOrPromise extends Promise<ApolloClient<any>> | ApolloClient<any>,\n>(\n  makeClient: () => ApolloClientOrPromise\n): {\n  getClient: () => ApolloClientOrPromise;\n  query: Awaited<ApolloClientOrPromise>[\"query\"];\n  /**\n   * Preloads data in React Server Components to be hydrated\n   * in Client Components.\n   *\n   * ### Example with `queryRef`\n   * `ClientChild` would call `useReadQuery` with the `queryRef`, the `Suspense` boundary is optional:\n   * ```jsx\n   * <PreloadQuery\n   *    query={QUERY}\n   *    variables={{\n   *      foo: 1\n   *    }}\n   *  >\n   *   {(queryRef) => (\n   *     <Suspense fallback={<>loading</>}>\n   *       <ClientChild queryRef={queryRef} />\n   *     </Suspense>\n   *   )}\n   * </PreloadQuery>\n   * ```\n   *\n   * ### Example for `useSuspenseQuery`\n   * `ClientChild` would call the same query with `useSuspenseQuery`, the `Suspense` boundary is optional:\n   * ```jsx\n   *  <PreloadQuery\n   *    query={QUERY}\n   *    variables={{\n   *      foo: 1\n   *    }}\n   *  >\n   *    <Suspense fallback={<>loading</>}>\n   *      <ClientChild />\n   *    </Suspense>\n   *  </PreloadQuery>\n   * ```\n   */\n  PreloadQuery: PreloadQueryComponent;\n} {\n  const getClient = makeGetClient(makeClient);\n  /*\n  We create an independent instance of Apollo Client per request,\n  because we don't want to mix up RSC-specific data with Client-specific\n  data in the same `InMemoryCache` instance.\n  */\n  const getPreloadClient = makeGetClient(makeClient);\n  const PreloadQuery = makePreloadQuery(getPreloadClient);\n  return {\n    getClient,\n    query: async (...args) => {\n      if (checkForStableCache() !== checkForStableCache()) {\n        console.warn(\n          `\nThe \\`query\\` shortcut returned from \\`registerApolloClient\\` \nshould not be used in Server Action or Middleware environments.\n\nCalling it multiple times in those environments would \ncreate multiple independent \\`ApolloClient\\` instances.\n\nPlease create a single \\`ApolloClient\\` instance by calling \n\\`getClient()\\` at the beginning of your Server Action or Middleware \nfunction and then call \\`client.query\\` multiple times instead.\n          `.trim()\n        );\n      }\n      return (await getClient()).query(...args);\n    },\n    PreloadQuery,\n  };\n}\n\nfunction makeGetClient<\n  AC extends Promise<ApolloClient<any>> | ApolloClient<any>,\n>(makeClient: () => AC): () => AC {\n  // React invalidates the cache on each server request, so the wrapping\n  // object is needed to properly detect whether the client is a unique\n  // reference or not. We can warn if `cachedMakeWrappedClient` creates a new \"wrapper\",\n  // but with a `client` property that we have already seen before.\n  // In that case, not every call to `makeClient` would create a new\n  // `ApolloClient` instance.\n  function makeWrappedClient() {\n    return { client: makeClient() };\n  }\n\n  const cachedMakeWrappedClient = cache(makeWrappedClient);\n\n  function getClient() {\n    if (arguments.length) {\n      throw new Error(\n        `\nYou cannot pass arguments into \\`getClient\\`.\nPassing arguments to \\`getClient\\` returns a different instance\nof Apollo Client each time it is called with different arguments, potentially \nresulting in duplicate requests and a non-functional cache. \n      `.trim()\n      );\n    }\n    const wrapper = cachedMakeWrappedClient();\n    if (seenWrappers && seenClients) {\n      if (!seenWrappers.has(wrapper)) {\n        if (seenClients.has(wrapper.client)) {\n          console.warn(\n            `\nMultiple calls to \\`getClient\\` for different requests returned the same client instance.\nThis means that private user data could accidentally be shared between requests.\nThis happens, for example, if you create a global \\`ApolloClient\\` instance and your \\`makeClient\\`\nimplementation just looks like \\`() => client\\`.\nAlways call \\`new ApolloClient\\` **inside** your \\`makeClient\\` function and\nreturn a new instance every time \\`makeClient\\` is called.\n`.trim()\n          );\n        }\n        seenWrappers.add(wrapper);\n        seenClients.add(wrapper.client);\n      }\n    }\n    return wrapper.client;\n  }\n  return getClient;\n}\n\n/**\n * Props for `PreloadQueryComponent`\n * @see {@link PreloadQueryComponent}\n * @public\n */\nexport interface PreloadQueryProps<TData, TVariables extends OperationVariables>\n  extends PreloadQueryOptions<TVariables, TData> {\n  children:\n    | ReactNode\n    | ((\n        queryRef: TransportedQueryRef<NoInfer<TData>, NoInfer<TVariables>>\n      ) => ReactNode);\n}\n\n/**\n * Preloads data in React Server Components to be hydrated\n * in Client Components.\n *\n * ### Example with `queryRef`\n * `ClientChild` would call `useReadQuery` with the `queryRef`, the `Suspense` boundary is optional:\n * ```jsx\n * <PreloadQuery\n *    query={QUERY}\n *    variables={{\n *      foo: 1\n *    }}\n *  >\n *   {(queryRef) => (\n *     <Suspense fallback={<>loading</>}>\n *       <ClientChild queryRef={queryRef} />\n *     </Suspense>\n *   )}\n * </PreloadQuery>\n * ```\n *\n * ### Example for `useSuspenseQuery`\n * `ClientChild` would call the same query with `useSuspenseQuery`, the `Suspense` boundary is optional:\n * ```jsx\n *  <PreloadQuery\n *    query={QUERY}\n *    variables={{\n *      foo: 1\n *    }}\n *  >\n *    <Suspense fallback={<>loading</>}>\n *      <ClientChild />\n *    </Suspense>\n *  </PreloadQuery>\n * ```\n *\n * @public\n */\nexport interface PreloadQueryComponent {\n  <TData, TVariables extends OperationVariables>(\n    props: PreloadQueryProps<TData, TVariables>\n  ): React.ReactElement;\n}\n\nfunction makePreloadQuery(\n  getClient: () => Promise<ApolloClient<any>> | ApolloClient<any>\n) {\n  return function PreloadQuery<TData, TVariables extends OperationVariables>(\n    props: PreloadQueryProps<TData, TVariables>\n  ): React.ReactElement {\n    return <UnboundPreloadQuery getClient={getClient} {...props} />;\n  };\n}\n","import { SimulatePreloadedQuery } from \"./index.cc.js\";\nimport type {\n  ApolloClient,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport type { ReactNode } from \"react\";\nimport React from \"react\";\nimport type {\n  PreloadTransportedQueryOptions,\n  TransportedQueryRef,\n} from \"./transportedQueryRef.js\";\nimport { createTransportedQueryPreloader } from \"./transportedQueryRef.js\";\n\nexport type PreloadQueryOptions<TVariables, TData> =\n  PreloadTransportedQueryOptions<TVariables, TData> & {\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  };\nexport async function PreloadQuery<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  getClient,\n  children,\n  ...options\n}: PreloadQueryOptions<TVariables, TData> & {\n  getClient: () => ApolloClient<any> | Promise<ApolloClient<any>>;\n  children:\n    | ReactNode\n    | ((\n        queryRef: TransportedQueryRef<NoInfer<TData>, NoInfer<TVariables>>\n      ) => ReactNode);\n}): Promise<React.ReactElement> {\n  const preloader = createTransportedQueryPreloader(await getClient());\n  const { query, ...transportedOptions } = options;\n  const queryRef = preloader(query, transportedOptions);\n\n  return (\n    <SimulatePreloadedQuery<TData> queryRef={queryRef}>\n      {typeof children === \"function\" ? children(queryRef) : children}\n    </SimulatePreloadedQuery>\n  );\n}\n","import type { CacheKey } from \"@apollo/client/react/internal\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal/index.js\";\nimport {\n  readFromReadableStream,\n  teeToReadableStream,\n} from \"./ReadableStreamLink.js\";\nimport { skipDataTransport } from \"./DataTransportAbstraction/index.js\";\nimport type { ReadableStreamLinkEvent } from \"./ReadableStreamLink.js\";\nimport type { QueryRef } from \"@apollo/client/react/index.js\";\nimport { useApolloClient } from \"@apollo/client/react/index.js\";\nimport type {\n  DocumentNode,\n  ApolloClient,\n  QueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client/index.js\";\nimport {\n  serializeOptions,\n  deserializeOptions,\n  type TransportedOptions,\n} from \"./DataTransportAbstraction/transportedOptions.js\";\nimport { useEffect } from \"react\";\nimport { canonicalStringify } from \"@apollo/client/cache/index.js\";\nimport {\n  JSONDecodeStream,\n  JSONEncodeStream,\n  type JsonString,\n} from \"@apollo/client-react-streaming/stream-utils\";\n\ntype RestrictedPreloadOptions = {\n  fetchPolicy?: \"network-only\" | \"cache-and-network\" | \"cache-first\";\n  returnPartialData?: false;\n  nextFetchPolicy?: undefined;\n  pollInterval?: undefined;\n};\n\n/** @public */\nexport type PreloadTransportedQueryOptions<TVariables, TData> = Omit<\n  QueryOptions<TVariables, TData>,\n  \"query\"\n> &\n  RestrictedPreloadOptions;\n\ntype TransportedQueryRefOptions = TransportedOptions & RestrictedPreloadOptions;\n\n/**\n * A `TransportedQueryRef` is an opaque object accessible via renderProp within `PreloadQuery`.\n *\n * A child client component reading the `TransportedQueryRef` via useReadQuery will suspend until the promise resolves.\n *\n * @public\n */\nexport interface TransportedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> extends QueryRef<TData, TVariables> {\n  /**\n   * Temporarily disabled - see https://github.com/apollographql/apollo-client-integrations/issues/332\n   *\n   * Will now be be `undefined` both in React Server Components and Client Components until we can find a better resolution.\n   */\n  toPromise?: undefined;\n  /** @internal */\n  $__apollo_queryRef: {\n    options: TransportedQueryRefOptions;\n    stream: ReadableStream<JsonString<ReadableStreamLinkEvent>>;\n    /**\n     * A unique key for this query, to ensure it is only hydrated once,\n     * even if it should get transported over the wire in a way that results\n     * in multiple objects describing the same queryRef.\n     * This key will be used to store the queryRef in the suspence cache.\n     *\n     * The chances of this happening should be slim (it is handled within\n     * React thanks to https://github.com/facebook/react/pull/28996), but\n     * as we use transported queryRefs with multiple frameworks with distinct\n     * transport mechanisms, this seems like a safe option.\n     */\n    queryKey: string;\n  };\n}\n\n/** @public */\nexport interface PreloadTransportedQueryFunction {\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options?: PreloadTransportedQueryOptions<NoInfer<TVariables>, TData>\n  ): TransportedQueryRef<TData, TVariables>;\n}\n\n/** @internal */\nexport function getInjectableEventStream() {\n  let controller:\n    | ReadableStreamDefaultController<ReadableStreamLinkEvent>\n    | undefined;\n  const stream = new ReadableStream<ReadableStreamLinkEvent>({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [controller!, stream] as const;\n}\n\n/** @public */\nexport function createTransportedQueryPreloader(\n  client: ApolloClient<any>\n): PreloadTransportedQueryFunction {\n  return (...[query, options]: Parameters<PreloadTransportedQueryFunction>) => {\n    // unset options that we do not support\n    options = { ...options };\n    delete options.returnPartialData;\n    delete options.nextFetchPolicy;\n    delete options.pollInterval;\n\n    const [controller, stream] = getInjectableEventStream();\n\n    // Instead of creating the queryRef, we kick off a query that will feed the network response\n    // into our custom event stream.\n    client\n      .query({\n        query,\n        ...options,\n        // ensure that this query makes it to the network\n        fetchPolicy: \"no-cache\",\n        context: skipDataTransport(\n          teeToReadableStream(() => controller, {\n            ...options?.context,\n            // we want to do this even if the query is already running for another reason\n            queryDeduplication: false,\n          })\n        ),\n      })\n      .catch(() => {\n        /* we want to avoid any floating promise rejections */\n      });\n\n    return createTransportedQueryRef<any, any>(\n      query,\n      options,\n      crypto.randomUUID(),\n      stream\n    );\n  };\n}\n\nfunction createTransportedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: PreloadTransportedQueryOptions<NoInfer<TVariables>, TData>,\n  queryKey: string,\n  stream: ReadableStream<ReadableStreamLinkEvent>\n): TransportedQueryRef<TData, TVariables> {\n  return {\n    $__apollo_queryRef: {\n      options: sanitizeForTransport(serializeOptions({ query, ...options })),\n      queryKey,\n      stream: stream.pipeThrough(new JSONEncodeStream()),\n    },\n  };\n}\n\nconst hydrationCache = new WeakMap<\n  TransportedQueryRef,\n  { cacheKey: CacheKey }\n>();\n\n/** @public */\nexport function reviveTransportedQueryRef(\n  queryRef: TransportedQueryRef,\n  client: ApolloClient<any>\n): asserts queryRef is TransportedQueryRef &\n  ReturnType<typeof wrapQueryRef<any, any>> {\n  const {\n    $__apollo_queryRef: { options, stream, queryKey },\n  } = queryRef;\n  if (!hydrationCache.has(queryRef)) {\n    const hydratedOptions = deserializeOptions(options);\n    const cacheKey: CacheKey = [\n      hydratedOptions.query,\n      canonicalStringify(hydratedOptions.variables),\n      queryKey,\n    ];\n    hydrationCache.set(queryRef, { cacheKey });\n    const internalQueryRef = getSuspenseCache(client).getQueryRef(\n      cacheKey,\n      () =>\n        client.watchQuery({\n          ...hydratedOptions,\n          fetchPolicy: \"network-only\",\n          context: skipDataTransport(\n            readFromReadableStream(stream.pipeThrough(new JSONDecodeStream()), {\n              ...hydratedOptions.context,\n              queryDeduplication: true,\n            })\n          ),\n        })\n    );\n    Object.assign(queryRef, wrapQueryRef(internalQueryRef));\n  }\n}\n\n/** @public */\nexport function isTransportedQueryRef(\n  queryRef: any\n): queryRef is TransportedQueryRef {\n  return !!(queryRef && queryRef.$__apollo_queryRef);\n}\n\n/** @public */\nexport function useWrapTransportedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables> | TransportedQueryRef\n): QueryRef<TData, TVariables> {\n  const client = useApolloClient();\n  let cacheKey: CacheKey | undefined;\n  let isTransported: boolean;\n  if ((isTransported = isTransportedQueryRef(queryRef))) {\n    reviveTransportedQueryRef(queryRef, client);\n    cacheKey = hydrationCache.get(queryRef)?.cacheKey;\n  }\n  const unwrapped = unwrapQueryRef<any>(queryRef)!;\n\n  useEffect(() => {\n    // We only want this to execute if the queryRef is a transported query.\n    if (!isTransported) return;\n    // We want to always keep this queryRef in the suspense cache in case another component has another instance of this transported queryRef.\n    if (cacheKey) {\n      if (unwrapped.disposed) {\n        getSuspenseCache(client).add(cacheKey, unwrapped);\n      }\n    }\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n  // Soft-retaining because useQueryRefHandlers doesn't do it for us.\n  useEffect(() => {\n    if (isTransported) {\n      return unwrapped.softRetain();\n    }\n  }, [isTransported, unwrapped]);\n  return queryRef;\n}\n\nfunction sanitizeForTransport<T>(value: T) {\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n","import { ApolloLink, Observable } from \"@apollo/client/index.js\";\nimport type { FetchResult } from \"@apollo/client/index.js\";\n\n/**\n * @internal\n */\nexport type ReadableStreamLinkEvent =\n  | { type: \"next\"; value: FetchResult }\n  | { type: \"completed\" }\n  | { type: \"error\" };\n\n/**\n * Called when the link is hit, before the request is forwarded.\n *\n * Should return the controller for the readable stream.\n *\n * This is useful because when starting a query, it's not always\n * clear if the query will hit the network or will be served from\n * cache, deduplicated etc.\n * This allows to inject the \"start event\" into the stream only\n * when we know that more chunks will actually follow.\n */\ntype OnLinkHitFunction =\n  () => ReadableStreamDefaultController<ReadableStreamLinkEvent>;\ninterface InternalContext {\n  [teeToReadableStreamKey]?: OnLinkHitFunction;\n  [readFromReadableStreamKey]?: ReadableStream<ReadableStreamLinkEvent>;\n}\n\nconst teeToReadableStreamKey = Symbol.for(\n  \"apollo.tee.readableStreamController\"\n);\nconst readFromReadableStreamKey = Symbol.for(\"apollo.read.readableStream\");\n\n/**\n * Apply to a context that will be passed to a link chain containing `TeeToReadableStreamLink`.\n * @public\n */\nexport function teeToReadableStream<T extends Record<string, any>>(\n  onLinkHit: OnLinkHitFunction,\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [teeToReadableStreamKey]: onLinkHit,\n  });\n}\n\n/**\n * Apply to a context that will be passed to a link chain containing `ReadFromReadableStreamLink`.\n * @public\n */\nexport function readFromReadableStream<T extends Record<string, any>>(\n  readableStream: ReadableStream<ReadableStreamLinkEvent>,\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [readFromReadableStreamKey]: readableStream,\n  });\n}\n\n/**\n * A link that allows the request to be cloned into a readable stream, e.g. for\n * transport of multipart responses from RSC or a server loader to the browser.\n * @public\n */\nexport class TeeToReadableStreamLink extends ApolloLink {\n  constructor() {\n    super((operation, forward) => {\n      const context = operation.getContext() as InternalContext;\n\n      const onLinkHit = context[teeToReadableStreamKey];\n\n      if (onLinkHit) {\n        const controller = onLinkHit();\n\n        const tryClose = () => {\n          try {\n            controller.close();\n          } catch {\n            // maybe we already tried to close the stream, nothing to worry about\n          }\n        };\n        return new Observable((observer) => {\n          const subscription = forward(operation).subscribe({\n            next(result) {\n              controller.enqueue({ type: \"next\", value: result });\n              observer.next(result);\n            },\n            error(error) {\n              controller.enqueue({ type: \"error\" });\n              tryClose();\n              observer.error(error);\n            },\n            complete() {\n              controller.enqueue({ type: \"completed\" });\n              tryClose();\n              observer.complete();\n            },\n          });\n\n          return () => {\n            tryClose();\n            subscription.unsubscribe();\n          };\n        });\n      }\n\n      return forward(operation);\n    });\n  }\n}\n\n/**\n * A link that allows the response to be read from a readable stream, e.g. for\n * hydration of a multipart response from RSC or a server loader in the browser.\n * @public\n */\nexport class ReadFromReadableStreamLink extends ApolloLink {\n  constructor() {\n    super((operation, forward) => {\n      const context = operation.getContext() as InternalContext;\n\n      const eventSteam = context[readFromReadableStreamKey];\n      if (eventSteam) {\n        return new Observable((observer) => {\n          let aborted = false as boolean;\n          const reader = (() => {\n            try {\n              return eventSteam.getReader();\n            } catch {\n              /**\n               * The reader could not be created, usually because the stream has\n               * already been consumed.\n               * This would be the case if we call `refetch` on a queryRef that has\n               * the `readFromReadableStreamKey` property in context.\n               * In that case, we want to do a normal network request.\n               */\n            }\n          })();\n\n          if (!reader) {\n            // if we can't create a reader, we want to do a normal network request\n            const subscription = forward(operation).subscribe(observer);\n            return () => subscription.unsubscribe();\n          }\n          consume(reader);\n\n          let onAbort = () => {\n            aborted = true;\n            reader.cancel();\n          };\n\n          return () => onAbort();\n\n          async function consume(\n            reader: ReadableStreamDefaultReader<ReadableStreamLinkEvent>\n          ) {\n            let event:\n              | ReadableStreamReadResult<ReadableStreamLinkEvent>\n              | undefined = undefined;\n            while (!aborted && !event?.done) {\n              event = await reader.read();\n              if (aborted) break;\n              if (event.value) {\n                switch (event.value.type) {\n                  case \"next\":\n                    observer.next(event.value.value);\n                    break;\n                  case \"completed\":\n                    observer.complete();\n                    break;\n                  case \"error\":\n                    // in case a network error happened on the sending side,\n                    if (process.env.REACT_ENV === \"ssr\") {\n                      // we want to fail SSR for this tree\n                      observer.error(\n                        new Error(\n                          \"Error from event stream. Redacted for security concerns.\"\n                        )\n                      );\n                    } else {\n                      // we want to retry the operation on the receiving side\n                      onAbort();\n                      const subscription =\n                        forward(operation).subscribe(observer);\n                      onAbort = () => subscription.unsubscribe();\n                    }\n                    break;\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return forward(operation);\n    });\n  }\n}\n","import type { InMemoryCacheConfig } from \"@apollo/client/index.js\";\nimport { InMemoryCache as OrigInMemoryCache } from \"@apollo/client/index.js\";\nimport { bundle, sourceSymbol } from \"../bundleInfo.js\";\n/*\n * We just subclass `InMemoryCache` here so that `WrappedApolloClient`\n * can detect if it was initialized with an `InMemoryCache` instance that\n * was also exported from this package.\n * Right now, we don't have extra logic here, but we might have so again\n * in the future.\n * So we want to enforce this import path from the start to prevent future\n * subtle bugs if people update the package and don't read the patch notes.\n */\n/**\n * A version of `InMemoryCache` to be used with streaming SSR.\n *\n * For more documentation, please see {@link https://www.apollographql.com/docs/react/api/cache/InMemoryCache | the Apollo Client API documentation}.\n *\n * @public\n */\nexport class InMemoryCache extends OrigInMemoryCache {\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   *\n   * @internal\n   */\n  static readonly info = bundle;\n  [sourceSymbol]: string;\n  constructor(config?: InMemoryCacheConfig | undefined) {\n    super(config);\n    const info = (this.constructor as typeof InMemoryCache).info;\n    this[sourceSymbol] = `${info.pkg}:InMemoryCache`;\n  }\n}\n","export const bundle = {\n  pkg: \"@apollo/client-react-streaming\",\n};\n\nexport const sourceSymbol = Symbol.for(\"apollo.source_package\");\n","/* eslint-disable prefer-rest-params */\nimport type {\n  ApolloClientOptions,\n  OperationVariables,\n  WatchQueryOptions,\n  NormalizedCacheObject,\n} from \"@apollo/client/index.js\";\n\nimport {\n  ApolloLink,\n  ApolloClient as OrigApolloClient,\n  Observable,\n} from \"@apollo/client/index.js\";\nimport type { QueryManager } from \"@apollo/client/core/QueryManager.js\";\nimport { invariant } from \"ts-invariant\";\nimport { createBackpressuredCallback } from \"./backpressuredCallback.js\";\nimport type { InMemoryCache } from \"./WrappedInMemoryCache.js\";\nimport { hookWrappers } from \"./hooks.js\";\nimport type { HookWrappers } from \"@apollo/client/react/internal/index.js\";\nimport type {\n  ProgressEvent,\n  QueryEvent,\n  TransportIdentifier,\n} from \"./DataTransportAbstraction.js\";\nimport { bundle, sourceSymbol } from \"../bundleInfo.js\";\nimport { serializeOptions, deserializeOptions } from \"./transportedOptions.js\";\nimport { assertInstance } from \"../assertInstance.js\";\nimport type { ReadableStreamLinkEvent } from \"../ReadableStreamLink.js\";\nimport {\n  readFromReadableStream,\n  ReadFromReadableStreamLink,\n  teeToReadableStream,\n  TeeToReadableStreamLink,\n} from \"../ReadableStreamLink.js\";\nimport { getInjectableEventStream } from \"../transportedQueryRef.js\";\n\nfunction getQueryManager(\n  client: OrigApolloClient<unknown>\n): QueryManager<NormalizedCacheObject> & {\n  [wrappers]: HookWrappers;\n} {\n  return client[\"queryManager\"];\n}\n\ntype SimulatedQueryInfo = {\n  controller: ReadableStreamDefaultController<ReadableStreamLinkEvent>;\n  options: WatchQueryOptions<OperationVariables, any>;\n};\n\ninterface WrappedApolloClientOptions\n  extends Omit<\n    ApolloClientOptions<NormalizedCacheObject>,\n    \"cache\" | \"ssrMode\" | \"ssrForceFetchDelay\"\n  > {\n  cache: InMemoryCache;\n}\n\nconst wrappers = Symbol.for(\"apollo.hook.wrappers\");\nclass ApolloClientBase extends OrigApolloClient<NormalizedCacheObject> {\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   *\n   * @internal\n   */\n  static readonly info = bundle;\n\n  [sourceSymbol]: string;\n\n  constructor(options: WrappedApolloClientOptions) {\n    const warnings: string[] = [];\n    if (\"ssrMode\" in options) {\n      delete options.ssrMode;\n      warnings.push(\n        \"The `ssrMode` option is not supported in %s. Please remove it from your %s constructor options.\"\n      );\n    }\n    if (\"ssrForceFetchDelay\" in options) {\n      delete options.ssrForceFetchDelay;\n      warnings.push(\n        \"The `ssrForceFetchDelay` option is not supported in %s. Please remove it from your %s constructor options.\"\n      );\n    }\n    super(\n      process.env.REACT_ENV === \"rsc\" || process.env.REACT_ENV === \"ssr\"\n        ? {\n            connectToDevTools: false,\n            ...options,\n          }\n        : options\n    );\n    const info = (this.constructor as typeof ApolloClientBase).info;\n    this[sourceSymbol] = `${info.pkg}:ApolloClient`;\n\n    for (const warning of warnings) {\n      console.warn(warning, info.pkg, \"ApolloClient\");\n    }\n\n    assertInstance(\n      this.cache as unknown as InMemoryCache,\n      info,\n      \"InMemoryCache\"\n    );\n\n    this.setLink(this.link);\n  }\n\n  setLink(newLink: ApolloLink) {\n    super.setLink.call(\n      this,\n      ApolloLink.from([\n        new ReadFromReadableStreamLink(),\n        new TeeToReadableStreamLink(),\n        newLink,\n      ])\n    );\n  }\n}\n\nclass ApolloClientClientBaseImpl extends ApolloClientBase {\n  constructor(options: WrappedApolloClientOptions) {\n    super(options);\n    this.onQueryStarted = this.onQueryStarted.bind(this);\n\n    getQueryManager(this)[wrappers] = hookWrappers;\n  }\n\n  private simulatedStreamingQueries = new Map<\n    TransportIdentifier,\n    SimulatedQueryInfo\n  >();\n\n  onQueryStarted({ options, id }: Extract<QueryEvent, { type: \"started\" }>) {\n    const hydratedOptions = deserializeOptions(options);\n\n    const [controller, stream] = getInjectableEventStream();\n\n    const queryManager = getQueryManager(this);\n    const queryId = queryManager.generateQueryId();\n    queryManager\n      .fetchQuery(queryId, {\n        ...hydratedOptions,\n        query: queryManager.transform(hydratedOptions.query),\n        fetchPolicy: \"network-only\",\n        context: skipDataTransport(\n          readFromReadableStream(stream, {\n            ...hydratedOptions.context,\n            queryDeduplication: true,\n          })\n        ),\n      })\n      .finally(() => queryManager.removeQuery(queryId));\n\n    this.simulatedStreamingQueries.set(id, {\n      controller,\n      options: hydratedOptions,\n    });\n  }\n\n  onQueryProgress = (event: ProgressEvent) => {\n    const queryInfo = this.simulatedStreamingQueries.get(event.id);\n    if (!queryInfo) return;\n\n    if (\n      event.type === \"error\" ||\n      (event.type === \"next\" && event.value.errors)\n    ) {\n      /**\n       * At this point we're not able to correctly serialize the error over the wire\n       * so we do the next-best thing: restart the query in the browser as soon as it\n       * failed on the server.\n       * This matches up with what React will be doing (abort hydration and rerender)\n       * See https://github.com/apollographql/apollo-client-integrations/issues/52\n       */\n      this.simulatedStreamingQueries.delete(event.id);\n      if (process.env.REACT_ENV === \"browser\") {\n        invariant.debug(\n          \"Query failed on server, rerunning in browser:\",\n          queryInfo.options\n        );\n        this.rerunSimulatedQuery(queryInfo);\n      } else if (process.env.REACT_ENV === \"ssr\") {\n        invariant.debug(\n          \"Query failed upstream, will fail it during SSR and rerun it in the browser:\",\n          queryInfo.options\n        );\n        queryInfo.controller.error(new Error(\"Query failed upstream.\"));\n      }\n    } else if (event.type === \"completed\") {\n      this.simulatedStreamingQueries.delete(event.id);\n      queryInfo.controller.enqueue(event);\n    } else if (event.type === \"next\") {\n      queryInfo.controller.enqueue(event);\n    }\n  };\n\n  /**\n   * Can be called when the stream closed unexpectedly while there might still be unresolved\n   * simulated server-side queries going on.\n   * Those queries will be cancelled and then re-run in the browser.\n   */\n  rerunSimulatedQueries = () => {\n    for (const [id, queryInfo] of this.simulatedStreamingQueries) {\n      this.simulatedStreamingQueries.delete(id);\n      invariant.debug(\n        \"streaming connection closed before server query could be fully transported, rerunning:\",\n        queryInfo.options\n      );\n      this.rerunSimulatedQuery(queryInfo);\n    }\n  };\n  rerunSimulatedQuery = (queryInfo: SimulatedQueryInfo) => {\n    const queryManager = getQueryManager(this);\n    const queryId = queryManager.generateQueryId();\n    queryManager\n      .fetchQuery(queryId, {\n        ...queryInfo.options,\n        fetchPolicy: \"no-cache\",\n        query: queryManager.transform(queryInfo.options.query),\n        context: skipDataTransport(\n          teeToReadableStream(() => queryInfo.controller, {\n            ...queryInfo.options.context,\n            queryDeduplication: false,\n          })\n        ),\n      })\n      .finally(() => queryManager.removeQuery(queryId));\n  };\n}\n\nconst skipDataTransportKey = Symbol.for(\"apollo.dataTransport.skip\");\ninterface InternalContext {\n  [skipDataTransportKey]?: boolean;\n}\n\n/**\n * Apply to a context to prevent this operation from being transported over the SSR data transport mechanism.\n * @public\n */\nexport function skipDataTransport<T extends Record<string, any>>(\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [skipDataTransportKey]: true,\n  });\n}\n\nclass ApolloClientSSRImpl extends ApolloClientClientBaseImpl {\n  watchQueryQueue = createBackpressuredCallback<{\n    event: Extract<QueryEvent, { type: \"started\" }>;\n    observable: Observable<Exclude<QueryEvent, { type: \"started\" }>>;\n  }>();\n\n  pushEventStream(\n    options: WatchQueryOptions<any, any>\n  ): ReadableStreamDefaultController<ReadableStreamLinkEvent> {\n    const id = crypto.randomUUID() as TransportIdentifier;\n\n    const [controller, eventStream] = getInjectableEventStream();\n\n    const streamObservable = new Observable<\n      Exclude<QueryEvent, { type: \"started\" }>\n    >((subscriber) => {\n      function consume(\n        event: ReadableStreamReadResult<ReadableStreamLinkEvent>\n      ) {\n        const value = event.value;\n        if (value) {\n          subscriber.next({ ...value, id });\n        }\n        if (event.done) {\n          subscriber.complete();\n        } else {\n          reader.read().then(consume);\n        }\n      }\n      const reader = eventStream.getReader();\n      reader.read().then(consume);\n    });\n\n    this.watchQueryQueue.push({\n      event: {\n        type: \"started\",\n        options: serializeOptions(options),\n        id,\n      },\n      observable: streamObservable,\n    });\n\n    return controller;\n  }\n\n  watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>) {\n    if (\n      !(options.context as InternalContext | undefined)?.[skipDataTransportKey]\n    ) {\n      return super.watchQuery({\n        ...options,\n        context: teeToReadableStream(() => this.pushEventStream(options), {\n          ...options?.context,\n        }),\n      });\n    }\n    return super.watchQuery(options);\n  }\n}\n\nclass ApolloClientBrowserImpl extends ApolloClientClientBaseImpl {}\n\nclass ApolloClientRSCImpl extends ApolloClientBase {}\n\nconst ApolloClientImplementation =\n  /*#__PURE__*/ process.env.REACT_ENV === \"ssr\"\n    ? ApolloClientSSRImpl\n    : process.env.REACT_ENV === \"browser\"\n      ? ApolloClientBrowserImpl\n      : ApolloClientRSCImpl;\n\n/**\n * A version of `ApolloClient` to be used with streaming SSR or in React Server Components.\n *\n * For more documentation, please see {@link https://www.apollographql.com/docs/react/api/core/ApolloClient | the Apollo Client API documentation}.\n *\n * @public\n */\nexport class ApolloClient<\n    // this generic is obsolete as we require a `InMemoryStore`, which fixes this generic to `NormalizedCacheObject` anyways\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Ignored = NormalizedCacheObject,\n  >\n  extends (ApolloClientImplementation as typeof ApolloClientBase)\n  implements Partial<ApolloClientSSRImpl>\n{\n  /** @internal */\n  declare onQueryStarted?: ApolloClientSSRImpl[\"onQueryStarted\"];\n  /** @internal */\n  declare onQueryProgress?: ApolloClientSSRImpl[\"onQueryProgress\"];\n  /** @internal */\n  declare rerunSimulatedQueries?: ApolloClientSSRImpl[\"rerunSimulatedQueries\"];\n  /** @internal */\n  declare rerunSimulatedQuery?: ApolloClientSSRImpl[\"rerunSimulatedQuery\"];\n  /** @internal */\n  declare watchQueryQueue?: ApolloClientSSRImpl[\"watchQueryQueue\"];\n}\n","\"use client\";\nimport { useContext, useSyncExternalStore } from \"react\";\nimport { DataTransportContext } from \"./DataTransportAbstraction.js\";\nimport { equal } from \"@wry/equality\";\n\nconst CLEAN = {};\nconst enum WhichResult {\n  client,\n  server,\n}\n\n/**\n * A hook that mostly acts as an identity function.\n * It will only behave differently during\n * the first render on the client, in which case it will\n * try to return the last value it was called with by\n * the same component during SSR. If that is successful,\n * it will schedule another rerender, to after hydration\n * the component can change to client-side values instead.\n */\nexport function useTransportValue<T>(value: T): T {\n  const dataTransport = useContext(DataTransportContext);\n  if (!dataTransport)\n    throw new Error(\n      \"useTransportValue must be used within a streaming-specific ApolloProvider\"\n    );\n  const valueRef = dataTransport.useStaticValueRef<T | typeof CLEAN>(value);\n\n  const whichResult = useSyncExternalStore(\n    () => () => {},\n    () => WhichResult.client,\n    () =>\n      valueRef.current === CLEAN\n        ? WhichResult.client\n        : equal(value, valueRef.current)\n          ? WhichResult.client\n          : WhichResult.server\n  );\n\n  if (whichResult === WhichResult.client) {\n    // this value will never be used again\n    // so we can safely delete it to save memory\n    valueRef.current = CLEAN;\n  }\n\n  return whichResult === WhichResult.server ? (valueRef.current as T) : value;\n}\n","import type React from \"react\";\nimport type { Observable } from \"@apollo/client/index.js\";\nimport { createContext } from \"react\";\nimport type { TransportedOptions } from \"./transportedOptions.js\";\nimport type { ReadableStreamLinkEvent } from \"../ReadableStreamLink.ts\";\n\ninterface DataTransportAbstraction {\n  /**\n   * This hook should always return the first value it was called with.\n   *\n   * If used in the browser and SSR happened, it should return the value passed to it on the server.\n   */\n  useStaticValueRef<T>(value: T): { current: T };\n}\n\n/**\n * > This export is only available in React Client Components\n *\n * If you create a custom data transport, you need to wrap the child tree in a\n * `DataTransportContext.Provider` and provide the `DataTransportAbstraction` to it.\n *\n * See for example\n * https://github.com/apollographql/apollo-client-integrations/blob/37feeaa9aea69b90a974eb9cd0fbd636b62d841a/integration-test/experimental-react/src/WrappedApolloProvider.tsx\n *\n * @public\n */\nexport const DataTransportContext =\n  /*#__PURE__*/ createContext<DataTransportAbstraction | null>(null);\n\n/**\n * Interface to be implemented by a custom data transport component,\n * for usage with `WrapApolloProvider`.\n *\n * This component needs to provide a `DataTransportContext` to it's children.\n *\n * See for example\n * https://github.com/apollographql/apollo-client-integrations/blob/37feeaa9aea69b90a974eb9cd0fbd636b62d841a/integration-test/experimental-react/src/WrappedApolloProvider.tsx\n *\n * @public\n */\nexport type DataTransportProviderImplementation<\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ExtraProps = {},\n> = React.FC<\n  {\n    /** will be present in the Browser */\n    onQueryEvent?: (event: QueryEvent) => void;\n    /** will be present in the Browser */\n    rerunSimulatedQueries?: () => void;\n    /** will be present during SSR */\n    registerDispatchRequestStarted?: (\n      callback: (query: {\n        event: Extract<QueryEvent, { type: \"started\" }>;\n        observable: Observable<Exclude<QueryEvent, { type: \"started\" }>>;\n      }) => void\n    ) => void;\n    /** will always be present */\n    children: React.ReactNode;\n  } & ExtraProps\n>;\n\nexport type TransportIdentifier = string & { __transportIdentifier: true };\n\n/**\n * Events that will be emitted by a wrapped ApolloClient instance during\n * SSR on `DataTransportProviderImplementation.registerDispatchRequestStarted`,\n * to be transported to the browser and replayed there using\n * `DataTransportProviderImplementation.onQueryEvent`.\n *\n * @public\n */\nexport type QueryEvent =\n  | {\n      type: \"started\";\n      options: TransportedOptions;\n      id: TransportIdentifier;\n    }\n  | (ReadableStreamLinkEvent & {\n      id: TransportIdentifier;\n    });\n\nexport type ProgressEvent = Exclude<QueryEvent, { type: \"started\" }>;\n","import type { HookWrappers } from \"@apollo/client/react/internal/index.js\";\nimport { useTransportValue } from \"./useTransportValue.js\";\nimport { useWrapTransportedQueryRef } from \"../transportedQueryRef.js\";\nimport { useMemo } from \"react\";\n\nexport const hookWrappers: HookWrappers = {\n  useFragment(orig_useFragment) {\n    return wrap(orig_useFragment, [\"data\", \"complete\", \"missing\"]);\n  },\n  useQuery(orig_useQuery) {\n    return wrap<typeof orig_useQuery>(\n      process.env.REACT_ENV === \"ssr\"\n        ? (query, options) =>\n            orig_useQuery(query, { ...options, fetchPolicy: \"cache-only\" })\n        : orig_useQuery,\n      [\"data\", \"loading\", \"networkStatus\", \"called\"]\n    );\n  },\n  useSuspenseQuery(orig_useSuspenseQuery) {\n    return wrap(orig_useSuspenseQuery, [\"data\", \"networkStatus\"]);\n  },\n  useReadQuery(orig_useReadQuery) {\n    return wrap(\n      (queryRef) => {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        return orig_useReadQuery(useWrapTransportedQueryRef(queryRef));\n      },\n      [\"data\", \"networkStatus\"]\n    );\n  },\n  useQueryRefHandlers(orig_useQueryRefHandlers) {\n    return wrap((queryRef) => {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      return orig_useQueryRefHandlers(useWrapTransportedQueryRef(queryRef));\n    }, []);\n  },\n  useSuspenseFragment(orig_useSuspenseFragment) {\n    return wrap(orig_useSuspenseFragment, [\"data\"]);\n  },\n};\n\nfunction wrap<T extends (...args: any[]) => any>(\n  useFn: T,\n  transportKeys: (keyof ReturnType<T>)[]\n): T {\n  return ((...args: any[]) => {\n    const result = useFn(...args);\n    if (transportKeys.length == 0) {\n      return result;\n    }\n    const forTransport = useMemo<Partial<typeof result>>(() => {\n      const transport: Partial<typeof result> = {};\n      for (const key of transportKeys) {\n        transport[key] = result[key];\n      }\n      return transport;\n    }, [result]);\n    const transported = useTransportValue(forTransport);\n\n    return useMemo(\n      () => ({ ...result, ...transported }),\n      [result, transported]\n    );\n  }) as T;\n}\n","import { gql } from \"@apollo/client/index.js\";\nimport type {\n  WatchQueryOptions,\n  DocumentNode,\n  FetchPolicy,\n} from \"@apollo/client/index.js\";\nimport { print } from \"@apollo/client/utilities/index.js\";\nimport { stripIgnoredCharacters } from \"graphql\";\n\nexport type TransportedOptions = { query: string } & Omit<\n  WatchQueryOptions,\n  \"query\"\n>;\n\nexport function serializeOptions<T extends WatchQueryOptions<any, any>>(\n  options: T\n): { query: string; nextFetchPolicy?: FetchPolicy | undefined } & Omit<\n  T,\n  \"query\"\n> {\n  return {\n    ...(options as typeof options & {\n      // little bit of a hack around the method signature, but the method signature would cause React to error anyways\n      nextFetchPolicy?: FetchPolicy | undefined;\n    }),\n    query: printMinified(options.query),\n  };\n}\n\nexport function deserializeOptions(\n  options: TransportedOptions\n): WatchQueryOptions {\n  return {\n    ...options,\n    // `gql` memoizes results, but based on the input string.\n    // We parse-stringify-parse here to ensure that our minified query\n    // has the best chance of being the referential same query as the one used in\n    // client-side code.\n    query: gql(print(gql(options.query))),\n  };\n}\n\nfunction printMinified(query: DocumentNode): string {\n  return stripIgnoredCharacters(print(query));\n}\n","import type { bundle } from \"./bundleInfo.js\";\nimport { sourceSymbol } from \"./bundleInfo.js\";\n\nexport function assertInstance(\n  value: { [sourceSymbol]?: string },\n  info: typeof bundle,\n  name: string\n): void {\n  if (value[sourceSymbol] !== `${info.pkg}:${name}`) {\n    throw new Error(\n      `When using \\`${name}\\` in streaming SSR, you must use the \\`${name}\\` export provided by \\`\"${info.pkg}\"\\`.`\n    );\n  }\n}\n","\"use client\";\nimport React from \"react\";\nimport { useRef } from \"react\";\nimport type { ApolloClient } from \"./WrappedApolloClient.js\";\nimport { ApolloProvider } from \"@apollo/client/react/index.js\";\nimport type { DataTransportProviderImplementation } from \"./DataTransportAbstraction.js\";\nimport { ApolloClientSingleton } from \"./symbols.js\";\nimport { bundle } from \"../bundleInfo.js\";\nimport { assertInstance } from \"../assertInstance.js\";\n\ndeclare global {\n  interface Window {\n    [ApolloClientSingleton]?: ApolloClient<any>;\n  }\n}\n\n/**\n * > This is only available in React Client Components\n *\n * A version of `ApolloProvider` particularly suited for React's streaming SSR.\n *\n * @public\n */\nexport interface WrappedApolloProvider<ExtraProps> {\n  ({\n    makeClient,\n    children,\n    ...extraProps\n  }: React.PropsWithChildren<\n    {\n      makeClient: () => ApolloClient<any>;\n    } & ExtraProps\n  >): React.JSX.Element;\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   */\n  info: {\n    pkg: string;\n  };\n}\n\n/**\n * > This export is only available in React Client Components\n *\n * Creates an ApolloProvider for streaming SSR.\n *\n * @param TransportProvider - The transport provider to be used.\n * This could e.g. be a `ManualDataTransport` created by `buildManualDataTransport`,\n * or a fully custom implementation of `DataTransportProviderImplementation`.\n * @public\n */\nexport function WrapApolloProvider<ExtraProps>(\n  TransportProvider: DataTransportProviderImplementation<ExtraProps>\n): WrappedApolloProvider<ExtraProps> {\n  const WrappedApolloProvider: WrappedApolloProvider<ExtraProps> = ({\n    makeClient,\n    children,\n    ...extraProps\n  }) => {\n    const clientRef = useRef<ApolloClient<any>>(undefined);\n    if (!clientRef.current) {\n      if (process.env.REACT_ENV === \"ssr\") {\n        clientRef.current = makeClient();\n      } else {\n        clientRef.current = window[ApolloClientSingleton] ??= makeClient();\n      }\n      assertInstance(\n        clientRef.current,\n        WrappedApolloProvider.info,\n        \"ApolloClient\"\n      );\n    }\n\n    return (\n      <ApolloProvider client={clientRef.current}>\n        <TransportProvider\n          onQueryEvent={(event) =>\n            event.type === \"started\"\n              ? clientRef.current!.onQueryStarted!(event)\n              : clientRef.current!.onQueryProgress!(event)\n          }\n          rerunSimulatedQueries={clientRef.current.rerunSimulatedQueries}\n          registerDispatchRequestStarted={\n            clientRef.current.watchQueryQueue?.register\n          }\n          {...(extraProps as ExtraProps)}\n        >\n          {children}\n        </TransportProvider>\n      </ApolloProvider>\n    );\n  };\n  WrappedApolloProvider.info = bundle;\n  return WrappedApolloProvider;\n}\n","import type { Operation, NextLink, FetchResult } from \"@apollo/client/index.js\";\nimport { ApolloLink } from \"@apollo/client/index.js\";\nimport {\n  Observable,\n  hasDirectives,\n  mergeIncrementalData,\n} from \"@apollo/client/utilities/index.js\";\n\ninterface AccumulateMultipartResponsesConfig {\n  /**\n   * The maximum delay in milliseconds\n   * from receiving the first response\n   * until the accumulated data will be flushed\n   * and the connection will be closed.\n   */\n  cutoffDelay: number;\n}\n\n/**\n *\n * This link can be used to \"debounce\" the initial response of a multipart request. Any incremental data received during the `cutoffDelay` time will be merged into the initial response.\n *\n * After `cutoffDelay`, the link will return the initial response, even if there is still incremental data pending, and close the network connection.\n *\n * If `cutoffDelay` is `0`, the link will immediately return data as soon as it is received, without waiting for incremental data, and immediately close the network connection.\n *\n * @example\n * ```ts\n * new AccumulateMultipartResponsesLink({\n *   // The maximum delay in milliseconds\n *   // from receiving the first response\n *   // until the accumulated data will be flushed\n *   // and the connection will be closed.\n *   cutoffDelay: 100,\n *  });\n * ```\n *\n * @public\n */\nexport class AccumulateMultipartResponsesLink extends ApolloLink {\n  private maxDelay: number;\n\n  constructor(config: AccumulateMultipartResponsesConfig) {\n    super();\n    this.maxDelay = config.cutoffDelay;\n  }\n  request(operation: Operation, forward?: NextLink) {\n    if (!forward) {\n      throw new Error(\"This is not a terminal link!\");\n    }\n\n    const operationContainsMultipartDirectives = hasDirectives(\n      [\"defer\"],\n      operation.query\n    );\n\n    const upstream = forward(operation);\n    if (!operationContainsMultipartDirectives) return upstream;\n\n    // TODO: this could be overwritten with a `@AccumulateMultipartResponsesConfig(maxDelay: 1000)` directive on the operation\n    const maxDelay = this.maxDelay;\n    let accumulatedData: FetchResult, maxDelayTimeout: NodeJS.Timeout;\n\n    return new Observable<FetchResult>((subscriber) => {\n      const upstreamSubscription = upstream.subscribe({\n        next: (result) => {\n          if (accumulatedData) {\n            if (accumulatedData.data && \"incremental\" in result) {\n              accumulatedData.data = mergeIncrementalData(\n                accumulatedData.data,\n                result\n              );\n            } else if (result.data) {\n              accumulatedData.data = result.data;\n            }\n\n            if (result.errors) {\n              accumulatedData.errors = [\n                ...(accumulatedData.errors || []),\n                ...(result.errors || []),\n              ];\n            }\n\n            // the spec is not mentioning on how to merge these, so we just do a shallow merge?\n            if (result.extensions)\n              accumulatedData.extensions = {\n                ...accumulatedData.extensions,\n                ...result.extensions,\n              };\n          } else {\n            accumulatedData = result;\n          }\n          if (!maxDelay) {\n            flushAccumulatedData();\n          } else if (!maxDelayTimeout) {\n            maxDelayTimeout = setTimeout(flushAccumulatedData, maxDelay);\n          }\n        },\n        error: (error) => {\n          if (maxDelayTimeout) clearTimeout(maxDelayTimeout);\n          subscriber.error(error);\n        },\n        complete: () => {\n          if (maxDelayTimeout) {\n            clearTimeout(maxDelayTimeout);\n            flushAccumulatedData();\n          }\n          subscriber.complete();\n        },\n      });\n\n      function flushAccumulatedData() {\n        subscriber.next(accumulatedData);\n        subscriber.complete();\n        upstreamSubscription.unsubscribe();\n      }\n\n      return function cleanUp() {\n        clearTimeout(maxDelayTimeout);\n        upstreamSubscription.unsubscribe();\n      };\n    });\n  }\n}\n","import type {\n  Operation,\n  NextLink,\n  DocumentNode,\n} from \"@apollo/client/index.js\";\nimport { ApolloLink } from \"@apollo/client/index.js\";\nimport type { RemoveDirectiveConfig } from \"@apollo/client/utilities/index.js\";\nimport {\n  Observable,\n  removeDirectivesFromDocument,\n} from \"@apollo/client/utilities/index.js\";\nimport type { DirectiveNode } from \"graphql\";\n\ninterface RemoveMultipartDirectivesConfig {\n  /**\n   * Whether to strip fragments with `@defer` directives\n   * from queries before sending them to the server.\n   *\n   * Defaults to `true`.\n   *\n   * Can be overwritten by adding a label starting\n   * with either `\"SsrDontStrip\"` or `\"SsrStrip\"` to the\n   * directive.\n   */\n  stripDefer?: boolean;\n}\n\nfunction getDirectiveArgumentValue(directive: DirectiveNode, argument: string) {\n  return directive.arguments?.find((arg: any) => arg.name.value === argument)\n    ?.value;\n}\n/**\n * This link will (if called with `stripDefer: true`) strip all `@defer` fragments from your query.\n *\n * This is used to prevent the server from doing additional work in SSR scenarios where multipart responses cannot be handled anyways.\n *\n * You can exclude certain fragments from this behavior by giving them a label starting with `\"SsrDontStrip\"`.\n * The \"starting with\" is important, because labels have to be unique per operation. So if you have multiple directives where you want to override the default stipping behaviour,\n * you can do this by annotating them like\n * ```graphql\n * query myQuery {\n *   fastField\n *   ... @defer(label: \"SsrDontStrip1\") {\n *     slowField1\n *   }\n *   ... @defer(label: \"SsrDontStrip2\") {\n *     slowField2\n *   }\n * }\n * ```\n *\n * You can also use the link with `stripDefer: false` and mark certain fragments to be stripped by giving them a label starting with `\"SsrStrip\"`.\n *\n * @example\n * ```ts\n * new RemoveMultipartDirectivesLink({\n *   // Whether to strip fragments with `@defer` directives\n *   // from queries before sending them to the server.\n *   //\n *   // Defaults to `true`.\n *   //\n *   // Can be overwritten by adding a label starting\n *   // with either `\"SsrDontStrip\"` or `\"SsrStrip\"` to the\n *   // directive.\n *   stripDefer: true,\n * });\n * ```\n *\n * @public\n */\nexport class RemoveMultipartDirectivesLink extends ApolloLink {\n  private stripDirectives: string[] = [];\n  constructor(config: RemoveMultipartDirectivesConfig) {\n    super();\n\n    if (config.stripDefer !== false) this.stripDirectives.push(\"defer\");\n  }\n\n  request(operation: Operation, forward?: NextLink) {\n    if (!forward) {\n      throw new Error(\"This is not a terminal link!\");\n    }\n    const { query } = operation;\n\n    let modifiedQuery: DocumentNode | null = query;\n    modifiedQuery = removeDirectivesFromDocument(\n      this.stripDirectives\n        .map<RemoveDirectiveConfig>((directive) => ({\n          test(node) {\n            let shouldStrip =\n              node.kind === \"Directive\" && node.name.value === directive;\n            const label = getDirectiveArgumentValue(node, \"label\");\n            if (\n              label?.kind === \"StringValue\" &&\n              label.value.startsWith(\"SsrDontStrip\")\n            ) {\n              shouldStrip = false;\n            }\n            return shouldStrip;\n          },\n          remove: true,\n        }))\n        .concat({\n          test(node) {\n            if (node.kind !== \"Directive\") return false;\n            const label = getDirectiveArgumentValue(node, \"label\");\n            return (\n              label?.kind === \"StringValue\" &&\n              label.value.startsWith(\"SsrStrip\")\n            );\n          },\n          remove: true,\n        }),\n      modifiedQuery\n    );\n\n    if (modifiedQuery === null) {\n      return Observable.of({});\n    }\n\n    operation.query = modifiedQuery;\n\n    return forward(operation);\n  }\n}\n","import { ApolloLink } from \"@apollo/client/index.js\";\nimport { RemoveMultipartDirectivesLink } from \"./RemoveMultipartDirectivesLink.js\";\nimport { AccumulateMultipartResponsesLink } from \"./AccumulateMultipartResponsesLink.js\";\n\ninterface SSRMultipartLinkConfig {\n  /**\n   * Whether to strip fragments with `@defer` directives\n   * from queries before sending them to the server.\n   *\n   * Defaults to `true`.\n   *\n   * Can be overwritten by adding a label starting\n   * with either `\"SsrDontStrip\"` or `\"SsrStrip\"` to the\n   * directive.\n   */\n  stripDefer?: boolean;\n  /**\n   * The maximum delay in milliseconds\n   * from receiving the first response\n   * until the accumulated data will be flushed\n   * and the connection will be closed.\n   *\n   * Defaults to `0`.\n   */\n  cutoffDelay?: number;\n}\n\n/**\n * A convenient combination of `RemoveMultipartDirectivesLink` and `AccumulateMultipartResponsesLink`.\n *\n * @example\n * ```ts\n * new SSRMultipartLink({\n *   // Whether to strip fragments with `@defer` directives\n *   // from queries before sending them to the server.\n *   //\n *   // Defaults to `true`.\n *   //\n *   // Can be overwritten by adding a label starting\n *   // with either `\"SsrDontStrip\"` or `\"SsrStrip\"` to the\n *   // directive.\n *   stripDefer: true,\n *   // The maximum delay in milliseconds\n *   // from receiving the first response\n *   // until the accumulated data will be flushed\n *   // and the connection will be closed.\n *   //\n *   // Defaults to `0`.\n *   //\n *   cutoffDelay: 100,\n * });\n * ```\n *\n * @public\n */\nexport class SSRMultipartLink extends ApolloLink {\n  constructor(config: SSRMultipartLinkConfig = {}) {\n    const combined = ApolloLink.from([\n      new RemoveMultipartDirectivesLink({\n        stripDefer: config.stripDefer,\n      }),\n      new AccumulateMultipartResponsesLink({\n        cutoffDelay: config.cutoffDelay || 0,\n      }),\n    ]);\n    super(combined.request);\n  }\n}\n"]}