"use client";

// src/SimulatePreloadedQuery.cc.ts
import {
  useApolloClient as useApolloClient2,
  useBackgroundQuery
} from "@apollo/client/react/index.js";
import { useMemo as useMemo2 } from "react";

// src/transportedQueryRef.ts
import {
  getSuspenseCache,
  unwrapQueryRef,
  wrapQueryRef
} from "@apollo/client/react/internal/index.js";

// src/ReadableStreamLink.tsx
import { ApolloLink, Observable } from "@apollo/client/index.js";
var teeToReadableStreamKey = Symbol.for(
  "apollo.tee.readableStreamController"
);
var readFromReadableStreamKey = Symbol.for("apollo.read.readableStream");
function readFromReadableStream(readableStream, context) {
  return Object.assign(context, {
    [readFromReadableStreamKey]: readableStream
  });
}
var TeeToReadableStreamLink = class extends ApolloLink {
  constructor() {
    super((operation, forward) => {
      const context = operation.getContext();
      const onLinkHit = context[teeToReadableStreamKey];
      if (onLinkHit) {
        const controller = onLinkHit();
        const tryClose = () => {
          try {
            controller.close();
          } catch {
          }
        };
        return new Observable((observer) => {
          const subscription = forward(operation).subscribe({
            next(result) {
              controller.enqueue({ type: "next", value: result });
              observer.next(result);
            },
            error(error) {
              controller.enqueue({ type: "error" });
              tryClose();
              observer.error(error);
            },
            complete() {
              controller.enqueue({ type: "completed" });
              tryClose();
              observer.complete();
            }
          });
          return () => {
            tryClose();
            subscription.unsubscribe();
          };
        });
      }
      return forward(operation);
    });
  }
};
var ReadFromReadableStreamLink = class extends ApolloLink {
  constructor() {
    super((operation, forward) => {
      const context = operation.getContext();
      const eventSteam = context[readFromReadableStreamKey];
      if (eventSteam) {
        return new Observable((observer) => {
          let aborted = false;
          const reader = (() => {
            try {
              return eventSteam.getReader();
            } catch {
            }
          })();
          if (!reader) {
            const subscription = forward(operation).subscribe(observer);
            return () => subscription.unsubscribe();
          }
          consume(reader);
          let onAbort = () => {
            aborted = true;
            reader.cancel();
          };
          return () => onAbort();
          async function consume(reader2) {
            let event = void 0;
            while (!aborted && !event?.done) {
              event = await reader2.read();
              if (aborted)
                break;
              if (event.value) {
                switch (event.value.type) {
                  case "next":
                    observer.next(event.value.value);
                    break;
                  case "completed":
                    observer.complete();
                    break;
                  case "error":
                    if (false) {
                      observer.error(
                        new Error(
                          "Error from event stream. Redacted for security concerns."
                        )
                      );
                    } else {
                      onAbort();
                      const subscription = forward(operation).subscribe(observer);
                      onAbort = () => subscription.unsubscribe();
                    }
                    break;
                }
              }
            }
          }
        });
      }
      return forward(operation);
    });
  }
};

// src/DataTransportAbstraction/WrappedInMemoryCache.tsx
import { InMemoryCache as OrigInMemoryCache } from "@apollo/client/index.js";

// src/bundleInfo.ts
var bundle = {
  pkg: "@apollo/client-react-streaming"
};
var sourceSymbol = Symbol.for("apollo.source_package");

// src/DataTransportAbstraction/WrappedInMemoryCache.tsx
var InMemoryCache = class extends OrigInMemoryCache {
  /**
   * Information about the current package and it's export names, for use in error messages.
   *
   * @internal
   */
  static info = bundle;
  [sourceSymbol];
  constructor(config) {
    super(config);
    const info = this.constructor.info;
    this[sourceSymbol] = `${info.pkg}:InMemoryCache`;
  }
};

// src/DataTransportAbstraction/WrappedApolloClient.tsx
import {
  ApolloLink as ApolloLink2,
  ApolloClient as OrigApolloClient,
  Observable as Observable2
} from "@apollo/client/index.js";
import { invariant } from "ts-invariant";

// src/DataTransportAbstraction/useTransportValue.tsx
import { useContext, useSyncExternalStore } from "react";

// src/DataTransportAbstraction/DataTransportAbstraction.ts
import { createContext } from "react";

// src/DataTransportAbstraction/useTransportValue.tsx
import { equal } from "@wry/equality";

// src/DataTransportAbstraction/hooks.ts
import { useMemo } from "react";

// src/DataTransportAbstraction/transportedOptions.ts
import { gql } from "@apollo/client/index.js";
import { print } from "@apollo/client/utilities/index.js";
import { stripIgnoredCharacters } from "graphql";
function deserializeOptions(options) {
  return {
    ...options,
    // `gql` memoizes results, but based on the input string.
    // We parse-stringify-parse here to ensure that our minified query
    // has the best chance of being the referential same query as the one used in
    // client-side code.
    query: gql(print(gql(options.query)))
  };
}

// src/assertInstance.ts
function assertInstance(value, info, name) {
  if (value[sourceSymbol] !== `${info.pkg}:${name}`) {
    throw new Error(
      `When using \`${name}\` in streaming SSR, you must use the \`${name}\` export provided by \`"${info.pkg}"\`.`
    );
  }
}

// src/DataTransportAbstraction/WrappedApolloClient.tsx
var wrappers = Symbol.for("apollo.hook.wrappers");
var ApolloClientBase = class extends OrigApolloClient {
  /**
   * Information about the current package and it's export names, for use in error messages.
   *
   * @internal
   */
  static info = bundle;
  [sourceSymbol];
  constructor(options) {
    const warnings = [];
    if ("ssrMode" in options) {
      delete options.ssrMode;
      warnings.push(
        "The `ssrMode` option is not supported in %s. Please remove it from your %s constructor options."
      );
    }
    if ("ssrForceFetchDelay" in options) {
      delete options.ssrForceFetchDelay;
      warnings.push(
        "The `ssrForceFetchDelay` option is not supported in %s. Please remove it from your %s constructor options."
      );
    }
    super(
      false ? {
        connectToDevTools: false,
        ...options
      } : options
    );
    const info = this.constructor.info;
    this[sourceSymbol] = `${info.pkg}:ApolloClient`;
    for (const warning of warnings) {
      console.warn(warning, info.pkg, "ApolloClient");
    }
    assertInstance(
      this.cache,
      info,
      "InMemoryCache"
    );
    this.setLink(this.link);
  }
  setLink(newLink) {
    super.setLink.call(
      this,
      ApolloLink2.from([
        new ReadFromReadableStreamLink(),
        new TeeToReadableStreamLink(),
        newLink
      ])
    );
  }
};
var skipDataTransportKey = Symbol.for("apollo.dataTransport.skip");
function skipDataTransport(context) {
  return Object.assign(context, {
    [skipDataTransportKey]: true
  });
}

// src/DataTransportAbstraction/WrapApolloProvider.tsx
import React from "react";
import { useRef } from "react";
import { ApolloProvider } from "@apollo/client/react/index.js";

// src/transportedQueryRef.ts
import { useApolloClient } from "@apollo/client/react/index.js";
import { useEffect } from "react";
import { canonicalStringify } from "@apollo/client/cache/index.js";
import {
  JSONDecodeStream,
  JSONEncodeStream
} from "@apollo/client-react-streaming/stream-utils";
var hydrationCache = /* @__PURE__ */ new WeakMap();
function reviveTransportedQueryRef(queryRef, client) {
  const {
    $__apollo_queryRef: { options, stream, queryKey }
  } = queryRef;
  if (!hydrationCache.has(queryRef)) {
    const hydratedOptions = deserializeOptions(options);
    const cacheKey = [
      hydratedOptions.query,
      canonicalStringify(hydratedOptions.variables),
      queryKey
    ];
    hydrationCache.set(queryRef, { cacheKey });
    const internalQueryRef = getSuspenseCache(client).getQueryRef(
      cacheKey,
      () => client.watchQuery({
        ...hydratedOptions,
        fetchPolicy: "network-only",
        context: skipDataTransport(
          readFromReadableStream(stream.pipeThrough(new JSONDecodeStream()), {
            ...hydratedOptions.context,
            queryDeduplication: true
          })
        )
      })
    );
    Object.assign(queryRef, wrapQueryRef(internalQueryRef));
  }
}

// src/SimulatePreloadedQuery.cc.ts
function SimulatePreloadedQuery({
  queryRef,
  children
}) {
  const client = useApolloClient2();
  reviveTransportedQueryRef(queryRef, client);
  const bgQueryArgs = useMemo2(() => {
    const { query, ...hydratedOptions } = deserializeOptions(
      queryRef.$__apollo_queryRef.options
    );
    return [
      query,
      { ...hydratedOptions, queryKey: queryRef.$__apollo_queryRef.queryKey }
    ];
  }, [queryRef.$__apollo_queryRef]);
  useBackgroundQuery(...bgQueryArgs);
  return children;
}
export {
  SimulatePreloadedQuery as default
};
export const built_for_browser = true;
//# sourceMappingURL=SimulatePreloadedQuery.cc.js.map